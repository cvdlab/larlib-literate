\documentclass[10pt]{book}
\usepackage{cite}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\hypersetup{colorlinks = true}

\author{Alberto Paoluzzi, Francesco Furiani, Giulio Martella}
\title{Linear Algebraic Representation}

\begin{document}

\frontmatter
\maketitle
\tableofcontents





\mainmatter

\chapter{Minimal cycles computation}
\label{ch:minimal_cycles}

\section{Main function}


Computing the minimal cycles means to compute the $d$-boundary matrix
from the $(d-1)$-boundary. This function works for both $d=2$ and $d=3$;
the only difference between the two cases lays in the \texttt{angles\_fn}
function (ref. \ref{sec:angles_fn}). To support this multidimensional
behavior, the algorithm has been implemented as an high-order function\footnote{
    \textbf{Notes on variables names:} \texttt{ld} stands for \textit{lower dimension} ($d-1$)
    and \texttt{lld} for \textit{lower lower dimension} ($d-2$). So, \texttt{ld\_cellsnum} is the
    short form of \textit{lower dimension cell number}. For example, if $d=2$, \texttt{ld\_cellsnum} stands for the
    number of $1-$cells, aka the edges.
}:

@O lib/jl/minimal_cycles.jl
@{include("./utilities.jl")

@< Minimal cycles implementations @>

function minimal_cycles(angles_fn::Function)

    function _minimal_cycles(V::Verts, ld_bounds::Cells)
        @< Function body @>
    end

    return _minimal_cycles
end
@}

In the internal function we store an array of integers called \texttt{count\_marks} 
that increments every time a cells is visited. We do that because to build 
a complete $d$-boundary, we must visit every $(d-1)$-cell exactly twice;
Said so, it appears clear that the algorithm must iterate until a $(d-1)$-cell 
marked with 0 or 1 can be found. Near to \texttt{count\_marks} is stored another
array called \texttt{dir\_marks} that memorizes the direction in which each $(d-1)$-cell
has been visited the last time (this is useful to determine the direction in which the cell
must be visited next)

@D Function body
@{lld_cellsnum, ld_cellsnum = size(ld_bounds)
count_marks = zeros(Int8, ld_cellsnum)
dir_marks = zeros(Int8, ld_cellsnum)
d_bounds = spzeros(Int8, ld_cellsnum, 0)

@< minimal\_cycles local variables @>
@< minimal\_cycles utilities @>

while (sigma = get_seed_cell()) > 0
    @< Compute a cycle @>
end

return d_bounds
@}

The \texttt{get\_seed\_cell} function returns the first $d-1$ cell
marked with zero. If there are no cells marked with zero, the first cell
marked with one will be returned. If every cell is marked with 2 then $-1$
will be returned.

@D minimal\_cycles utilities
@{function get_seed_cell()
    s = -1
    for i in 1:ld_cellsnum
        if count_marks[i] == 0
            return i
        elseif count_marks[i] == 1 && s < 0
            s = i
        end
    end
    return s
end
@}

The bigger part of the algorithm is the computation
of a single cycle. It is mostly equivalent to the
\textbf{ALGORITHM 1} presented by A. Paoluzzi et al.
in \textit{Arrangements of cellular complexes}
\cite{Paoluzzi}

@D Compute a cycle
@{c_ld = spzeros(Int8, ld_cellsnum)
if count_marks[sigma] == 0
    c_ld[sigma] = 1
else
    c_ld[sigma] = -dir_marks[sigma]
end
c_lld = ld_bounds*c_ld
while c_lld.nzind != []
    corolla = spzeros(Int8, ld_cellsnum)
    for tau in c_lld.nzind
        b_ld = ld_bounds[tau, :]
        pivot = intersect(c_ld.nzind, b_ld.nzind)[1]
        adj = nextprev(tau, pivot, sign(-c_lld[tau]))
        corolla[adj] = c_ld[pivot]
        if b_ld[adj] == b_ld[pivot]
            corolla[adj] *= -1
        end
    end
    c_ld += corolla
    c_lld = ld_bounds*c_ld
end
map(s->count_marks[s] += 1, c_ld.nzind)
map(s->dir_marks[s] = c_ld[s], c_ld.nzind)
d_bounds = [d_bounds c_ld]
@}

As profusely explained by A. Paoluzzi et al. \cite{Paoluzzi}, this algorithm
revolves around the \textit{next} and \textit{prev} functions. To speed up their
computation, before the cycles iteration starts, we calculate and
store for each ($d-2$)-cell the angles that its incident ($d-1$)-cells
form with it.

@D minimal\_cycles local variables
@{angles = Array{Array{Int64, 1}, 1}(lld_cellsnum)
@}

Here we use the parameter \texttt{angles\_fn::Function}. As explained earlier,
this function is the only difference between the $d=3$ and $d=2$ version of
\texttt{minimal\_cycles}.

@D minimal\_cycles utilities
@{
for lld in 1:lld_cellsnum
    as = [(ld, angles_fn(V, lld, ld_bounds[:, ld])) 
        for ld in ld_bounds[lld, :].nzind]
    sort!(as, lt=(a,b)->a[2]<b[2])
    as = map(a->a[1], as)
    angles[lld] = as
end
@}

Once computed the \texttt{angles}, the \texttt{nextprev} function is
easy to implement. The \texttt{norp} parameter is a short form for \textit{next or prev}. 
It determines if the function should choose the first available
($d-1$)-cell rotating clockwise or counterclockwise around the ($d-2$)-cell.

@D minimal\_cycles utilities
@{function nextprev(lld::Int64, ld::Int64, norp)
    as = angles[lld]
    ne = findfirst(as, ld)
    while true
        ne += norp
        if ne > length(as)
            ne = 1
        elseif ne < 1
            ne = length(as)
        end

        if count_marks[as[ne]] < 2
            break
        end
    end
    as[ne]
end
@}



\section{Dimensional wise implementations}
\label{sec:angles_fn}

\subsection{$d=2$}

When in $d=2$, ($d-2$)-cells are vertices and ($d-1$)-cells are edges.
The \texttt{edge\_angle} function uses the Julia's \texttt{atan2} 
built-in function to calculate the angle of the edge from the vertex point of view.

@D Minimal cycles implementations
@{function minimal_2cycles(V::Verts, ev::Cells)

    function edge_angle(V::Verts, v::Int, edge::Cell)
        v2 = setdiff(edge.nzind, [v])[1]
        x, y = V[v2, :] - V[v, :]
        return atan2(y, x)
    end

    for i in 1:ev.m
        j = ev[i,:].nzind[1]
        ev[i, j] = -1
    end
    VE = ev'

    EF = minimal_cycles(edge_angle)(V, VE)

    return EF'
end
@}

\subsection{$d=3$}

TODO


\backmatter


\bibliography{book}{}
\bibliographystyle{plain}
\end{document}