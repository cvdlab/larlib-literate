\chapter{Minimal cycles computation}
\label{ch:minimal_cycles}

\section{Main function}


Computing the minimal cycles means to compute the $d$-boundary matrix
from the $(d-1)$-boundary. This function works for both $d=2$ and $d=3$;
the only difference between the two cases lays in the \texttt{angles\_fn}
function (ref. \ref{sec:angles_fn}). To support this multidimensional
behavior, the algorithm has been implemented as an high-order function\footnote{
    \textbf{Notes on variables names:} \texttt{ld} stands for \textit{lower dimension} ($d-1$)
    and \texttt{lld} for \textit{lower lower dimension} ($d-2$). So, \texttt{ld\_cellsnum} is the
    short form of \textit{lower dimension cell number}. For example, if $d=2$, \texttt{ld\_cellsnum} stands for the
    number of $1-$cells, aka the edges.
}:

@O lib/jl/minimal_cycles.jl
@{include("./utilities.jl")
using TRIANGLE

@< Minimal cycles implementations @>

function minimal_cycles(angles_fn::Function)

    function _minimal_cycles(V::Verts, ld_bounds::Cells)
        @< Function body @>
    end

    return _minimal_cycles
end
@}

In the internal function we store an array of integers called \texttt{count\_marks} 
that increments every time a cells is visited. We do that because to build 
a complete $d$-boundary, we must visit every $(d-1)$-cell exactly twice;
Said so, it appears clear that the algorithm must iterate until a $(d-1)$-cell 
marked with 0 or 1 can be found. Near to \texttt{count\_marks} is stored another
array called \texttt{dir\_marks} that memorizes the direction in which each $(d-1)$-cell
has been visited the last time (this is useful to determine the direction in which the cell
must be visited next)

@D Function body
@{lld_cellsnum, ld_cellsnum = size(ld_bounds)
count_marks = zeros(Int8, ld_cellsnum)
dir_marks = zeros(Int8, ld_cellsnum)
d_bounds = spzeros(Int8, ld_cellsnum, 0)

@< minimal\_cycles local variables @>
@< minimal\_cycles utilities @>

while (sigma = get_seed_cell()) > 0
    println("sigma: ", sigma)
    @< Compute a cycle @>
end

return d_bounds
@}

The \texttt{get\_seed\_cell} function returns the first $d-1$ cell
marked with zero. If there are no cells marked with zero, the first cell
marked with one will be returned. If every cell is marked with 2 then $-1$
will be returned.

@D minimal\_cycles utilities
@{function get_seed_cell()
    s = -1
    for i in 1:ld_cellsnum
        if count_marks[i] == 0
            return i
        elseif count_marks[i] == 1 && s < 0
            s = i
        end
    end
    return s
end
@}

The bigger part of the algorithm is the computation
of a single cycle. It is mostly equivalent to the
\textbf{ALGORITHM 1} presented by A. Paoluzzi et al.
in \textit{Arrangements of cellular complexes}
\cite{Paoluzzi}

@D Compute a cycle
@{c_ld = spzeros(Int8, ld_cellsnum)
if count_marks[sigma] == 0
    c_ld[sigma] = 1
else
    c_ld[sigma] = -dir_marks[sigma]
end
c_lld = ld_bounds*c_ld
while c_lld.nzind != []
    corolla = spzeros(Int8, ld_cellsnum)
    for tau in c_lld.nzind
        b_ld = ld_bounds[tau, :]
        pivot = intersect(c_ld.nzind, b_ld.nzind)[1]
        adj = nextprev(tau, pivot, sign(-c_lld[tau]))
        corolla[adj] = c_ld[pivot]
        if b_ld[adj] == b_ld[pivot]
            corolla[adj] *= -1
        end
    end
    #=
    if sigma == 1
        println(c_ld)
        readline(STDIN)
    end
    =#
    c_ld += corolla
    c_lld = ld_bounds*c_ld
end
map(s->count_marks[s] += 1, c_ld.nzind)
map(s->dir_marks[s] = c_ld[s], c_ld.nzind)
d_bounds = [d_bounds c_ld]
@}

As profusely explained by A. Paoluzzi et al. \cite{Paoluzzi}, this algorithm
revolves around the \textit{next} and \textit{prev} functions. To speed up their
computation, before the cycles iteration starts, we calculate and
store for each ($d-2$)-cell the angles that its incident ($d-1$)-cells
form with it.

@D minimal\_cycles local variables
@{angles = Array{Array{Int64, 1}, 1}(lld_cellsnum)
@}

Here we use the parameter \texttt{angles\_fn::Function}. As explained earlier,
this function is the only difference between the $d=3$ and $d=2$ version of
\texttt{minimal\_cycles}.

@D minimal\_cycles utilities
@{
for lld in 1:lld_cellsnum
    as = []
    for ld in ld_bounds[lld, :].nzind
        push!(as, (ld, angles_fn(lld, ld)))
    end
    sort!(as, lt=(a,b)->a[2]<b[2])
    as = map(a->a[1], as)
    angles[lld] = as
end
@}

Once computed the \texttt{angles}, the \texttt{nextprev} function is
easy to implement. The \texttt{norp} parameter is a short form for \textit{next or prev}. 
It determines if the function should choose the first available
($d-1$)-cell rotating clockwise or counterclockwise around the ($d-2$)-cell.

@D minimal\_cycles utilities
@{function nextprev(lld::Int64, ld::Int64, norp)
    as = angles[lld]
    ne = findfirst(as, ld)
    while true
        ne += norp
        if ne > length(as)
            ne = 1
        elseif ne < 1
            ne = length(as)
        end

        if count_marks[as[ne]] < 2
            break
        end
    end
    as[ne]
end
@}



\section{Dimensional wise implementations}
\label{sec:angles_fn}

%%%%%%%%%%%%%%%%%%
\subsection{$d=2$}

When in $d=2$, ($d-2$)-cells are vertices and ($d-1$)-cells are edges.
The \texttt{edge\_angle} function uses the Julia's \texttt{atan2} 
built-in function to calculate the angle of the edge from the vertex point of view.

@D Minimal cycles implementations
@{function minimal_2cycles(V::Verts, EV::Cells)

    function edge_angle(v::Int, e::Int)
        edge = EV[e, :]
        v2 = setdiff(edge.nzind, [v])[1]
        x, y = V[v2, :] - V[v, :]
        return atan2(y, x)
    end

    for i in 1:EV.m
        j = min(EV[i,:].nzind...)
        EV[i, j] = -1
    end
    VE = EV'

    EF = minimal_cycles(edge_angle)(V, VE)

    return EF'
end
@}


%%%%%%%%%%%%%%%%%%
\subsection{$d=3$}

Here we have edges for ($d-2$)-cells and faces for ($d-1$)-cells.

@D Minimal cycles implementations
@{function minimal_3cycles(V::Verts, EV::Cells, FE::Cells)

    triangulated_faces = Array{Any, 1}(FE.m)

    function face_angle(e::Int, f::Int)
        if !isdefined(triangulated_faces, f)
            vs_idxs = Array{Int64, 1}()
            edges_idxs = FE[f, :].nzind
            edge_num = length(edges_idxs)
            edges = zeros(Int64, edge_num, 2)

            for (i, ee) in enumerate(edges_idxs)
                edge = EV[ee, :].nzind
                edges[i, :] = edge
                vs_idxs = union(vs_idxs, edge)
            end
            
            vs = V[vs_idxs, :]

            v1 = normalize(vs[2, :] - vs[1, :])
            v3 = [0 0 0]
            err = 1e-8
            i = 3
            while -err < norm(v3) < err
                v2 = normalize(vs[i, :] - vs[1, :])
                v3 = cross(v1, v2)
                i = i + 1
            end

            M = reshape([v1; v2; v3], 3, 3)

            vs = vs*M

            triangulated_faces[f] = TRIANGLE.constrained_triangulation(vs, vs_idxs, edges, fill(true, edge_num))
        end

        edge_vs = EV[e, :].nzind

        t = findfirst(x->edge_vs[1] in x && edge_vs[2] in x, triangulated_faces[f])
        
        # Indexes of the vertices of the triangle
        triangle = triangulated_faces[f][t]

        # Get normalized vector of hinge
        v1 = normalize(V[edge_vs[2], :] - V[edge_vs[1], :])

        # Build frame
        if abs(v1[1]) > abs(v1[2])
            invlen = 1. / sqrt(v1[1]*v1[1] + v1[3]*v1[3])
            v2 = [-v1[3]*invlen, 0, v1[1]*invlen]
        else
            invlen = 1. / sqrt(v1[2]*v1[2] + v1[3]*v1[3])
            v2 = [0, -v1[3]*invlen, v1[2]*invlen]
        end
        v3 = cross(v1, v2)

        # Build transformation matrix
        M = reshape([v1; v2; v3], 3, 3)

        # Transform
        third_v = setdiff(triangle, edge_vs)[1]
        vs = V[[edge_vs..., third_v], :]*M

        # return atan2 of 3rd with 1st
        v = vs[3, :] - vs[1, :]

        angle = atan2(v[2], v[3]) 

        return angle
    end

    EF = FE'

    FC = minimal_cycles(face_angle)(V, EF)

    return -FC'
end
@}
