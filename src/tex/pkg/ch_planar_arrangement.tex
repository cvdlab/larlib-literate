\chapter{Planar Arrangement}
\label{ch:planar_arrangement}

%%%%%%%%%%%%%%%%%%
\section{Overview}
\label{sec:planar_arrangement_intro}

Refer to the introduction for algorithm explanation
[ref. \ref{ch:arrangement_algorithm}].
In the implementation we also build and return a 
map from the original edges to the new ones: this 
is necessary infrastructure to later implement
boolean operations with ease.

@O lib/jl/planar_arrangement.jl
@{@< planar\_arrangement support functions @>

function planar_arrangement(V::Verts, EV::Cells, sigma::Cell=spzeros(Int8, 0); multiproc=false)
    edgenum = size(EV, 1)
    @< planar\_arrangement local variables @>

    if (multiproc == true)
        @< Run parallel planar\_arrangement @>
    else
        @< Run sequential planar\_arrangement @>
    end
    
    V, EV = rV, rEV

    @< Merge coincident vertices @>
    @< Delete edges outside sigma area @>
    @< Find maximal biconnected components @>
    @< Filter biconnected components @>
    @< Create faces @>  

    V, EV, FE, edge_map
end 
@}

The mapping from old edges to new ones is stored into \texttt{edge\_map}.

@D planar\_arrangement local variables
@{edge_map = Array{Array{Int, 1}, 1}(edgenum)
@}
%++++++++++++++++%
\subsection{Tests and examples}
Every function responsible for the planar arrangement is coupled by some tests. 
@O test/jl/planar_arrangement.jl
@{using Base.Test
using LARLIB

@< planar\_arrangement support functions tests @>
@}

Examples to show the functionalities implemented in this chapter
are defined at the end of it [ref. \ref{sec:planar_arrangement_examples}].



%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parallel approach}

The sequential implementation of the algorithm is straightforward:
fragment each edge in order and update the \texttt{edge\_map} at each step.

@D Run sequential planar\_arrangement
@{for i in 1:edgenum
    v, ev = frag_edge(V, EV, i)

    newedges_nums = map(x->x+finalcells_num, collect(1:size(ev, 1)))

    edge_map[i] = newedges_nums

    finalcells_num += size(ev, 1)
    rV, rEV = skel_merge(rV, rEV, v, ev)
end
@}


The parallel version is very similar to the one presented for the Spatial Arrangement
[ref. \ref{ch:spatial_arrangement}]. The only difference here is that we need to recompose the
data in order, so we use a \texttt{SortedDict} to store the data from of the out channel.
The \texttt{SortedDict} data structure is provided by the \texttt{DataStructures} Julia package.

@D LAR imports
@{using DataStructures
@}

The \texttt{frag\_edge\_channel} function is the job distributed to the workers
that fetch data from the in channel and feeds the results of \texttt{frag\_edge}
to the out channel.

@D planar\_arrangement support functions
@{function frag_edge_channel(in_chan, out_chan, V, EV)
    run_loop = true
    while run_loop
        edgenum = take!(in_chan)
        if edgenum != -1
            put!(out_chan, (edgenum, frag_edge(V, EV, edgenum)))
        else
            run_loop = false
        end
    end
end
@}

The definition of the channels, the set up of the workers, the dispatch,
the output data fetch and the reconstruction of the fragmented \texttt{V} and \texttt{EV} (with
relative \texttt{edge\_map}) is implemented here:

@D Run parallel planar\_arrangement
@{in_chan = RemoteChannel(()->Channel{Int64}(0))
out_chan = RemoteChannel(()->Channel{Tuple}(0))

ordered_dict = SortedDict{Int64,Tuple}()

@@schedule begin
    for i in 1:edgenum
        put!(in_chan,i)
    end
    for p in workers()
        put!(in_chan,-1)
    end
end

for p in workers()
    @@async Base.remote_do(frag_edge_channel, p, in_chan, out_chan, V, EV)
end

for i in 1:edgenum
    frag_done_job = take!(out_chan)
    ordered_dict[frag_done_job[1]] = frag_done_job[2]
end

for (dkey, dval) in ordered_dict
    i = dkey
    v, ev = dval
    newedges_nums = map(x->x+finalcells_num, collect(1:size(ev, 1)))
    
    edge_map[i] = newedges_nums
    
    finalcells_num += size(ev, 1)
    
    rV, rEV = skel_merge(rV, rEV, v, ev)
end
@}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Edge fragmentation}
%+++++++++++++++++++++++++++%
\subsection{Support function}
\label{sec:frag_edge}
The edge fragmentation is performed by using a function called \texttt{frag\_edge}.
It fragments the edge of index \texttt{edge\_idx} computing the intersections of
it with the other edges of the complex. It returns the updated vertices list and the freshly computed edges.
For every edge, it needs to check if the edge to fragment intersects with it. 
The actual edge intersections are computed by \texttt{intersect\_edges} function [ref. \ref{sec:intersect_edges}]
The intersection points are then sorted along the edge to fragment, and correct fragments (which are edges themselves)
are computed.

@D planar\_arrangement support functions
@{function frag_edge(V::Verts, EV::Cells, edge_idx::Int)
    alphas = Dict{Float64, Int}()
    edge = EV[edge_idx, :]
    verts = V[edge.nzind, :]
    for i in 1:size(EV, 1)
        if i != edge_idx
            intersection = intersect_edges(V, edge, EV[i, :])
            for (point, alpha) in intersection
                verts = [verts; point]
                alphas[alpha] = size(verts, 1)
            end
        end
    end

    alphas[0.0], alphas[1.0] = [1, 2]

    alphas_keys = sort(collect(keys(alphas)))
    edge_num = length(alphas_keys)-1
    verts_num = size(verts, 1)
    ev = spzeros(Int8, edge_num, verts_num)

    for i in 1:edge_num
        ev[i, alphas[alphas_keys[i]]] = 1
        ev[i, alphas[alphas_keys[i+1]]] = 1
    end

    verts, ev
end
@}
%+++++++++++++++++++++++++++++%
\subsection{Edge intersections}
\label{sec:intersect_edges}
Three major cases are to be considered when intersecting two edges:
\begin{enumerate}[noitemsep]
    \item They are not parallel
    \item They are colinear (they stand on the same line) 
    \item They are parallel but not colinear
\end{enumerate}
In the third case there will be no intersections for sure so this case is skipped.
When they are not parallel there will be no more than a single intersection; in this case
we use the method presented by Bourke\cite{Bourke} to calculate it.
Particular attention is needed on the case of colinear edges: it can happen
that \texttt{edge2} is contained into the bounds of the colinear \texttt{edge1}; in this case, both points of
\texttt{edge2} are to be considered intersection and hence must be returned. Because of this, 
the intersections are returned as a list than can contain from zero to two elements; 
each element is a couple containing the intersection
point and a parameter useful for sorting the fragmentation points of an edge.

Here we are doing floating-point numbers comparisons so we use a fixed
error to avoid numerical imprecisions [ref. \ref{sec:floating-point_error}].

@D planar\_arrangement support functions
@{function intersect_edges(V::Verts, edge1::Cell, edge2::Cell)
    err = 10e-8

    x1, y1, x2, y2 = vcat(map(c->V[c, :], edge1.nzind)...)
    x3, y3, x4, y4 = vcat(map(c->V[c, :], edge2.nzind)...)
    ret = Array{Tuple{Verts, Float64}, 1}()

    v1 = [x2-x1, y2-y1];
    v2 = [x4-x3, y4-y3];
    v3 = [x3-x1, y3-y1];

    @< Check if colinear or parallel @>

    if colinear
        @< Handle colinear edges @>
    elseif !parallel
        denom = (v2[2])*(v1[1]) - (v2[1])*(v1[2])
        a = ((v2[1])*(-v3[2]) - (v2[2])*(-v3[1])) / denom
        b = ((v1[1])*(-v3[2]) - (v1[2])*(-v3[1])) / denom

        if -err < a < 1+err && -err <= b <= 1+err
            p = [(x1 + a*(x2-x1))  (y1 + a*(y2-y1))]
            push!(ret, (p, a)) 
        end
    end

    return ret
end
@}

To check if edges are parallel, we check with the dot product 
the parallelism between the edges defining vectors.
Edges are colinear if they are parallel and the points of
the second edge stand on the line of the first edge
or one of the points of the second edge is coincident to
one point of the first one.

@D Check if colinear or parallel
@{ang1 = dot(normalize(v1), normalize(v2))
ang2 = dot(normalize(v1), normalize(v3))

parallel = 1-err < abs(ang1) < 1+err
colinear = parallel && (1-err < abs(ang2) < 1+err || -err < norm(v3) < err)
@}

In the case of colinearity, 
to find if \texttt{edge2} has one or both of 
its vertices inside \texttt{edge1} we follow this procedure:
\begin{enumerate}
\item We parametrize \texttt{edge1}:
\[
    p = p_1 + \alpha(p_2-p_1), \quad\alpha\in[0, 1]
\]
Where $p_1$ and $p_2$ are the vertices of \texttt{edge1}
\item We solve for $\alpha$:
\begin{gather*}
    o = p_1, \quad\vec{v} = p_2 - p_1 \\
    p = o + \alpha\vec{v} \\
    p - o = \alpha\vec{v} \\
    \vec{v}^\top\cdot(p-o) = \alpha (\vec{v}^\top\cdot\vec{v}) \\
    \alpha = \frac{\vec{v}^\top\cdot(p-o)}{\vec{v}^\top\cdot\vec{v}}
\end{gather*}
\item We replace $p$ of the last equation with both the vertices of \texttt{edge2}.
If the result is $\in[0,1]$ then an intersection is found.
\end{enumerate} 
@D Handle colinear edges
@{o = [x1 y1] 
v = [x2 y2] - o
alpha = 1/dot(v,v')
ps = [x3 y3; x4 y4]
for i in 1:2
    a = alpha*dot(v',(reshape(ps[i, :], 1, 2)-o))
    if 0 < a < 1
        push!(ret, (ps[i:i, :], a))
    end
end
@}
%+++++++++++++++++++++++++%
\subsection{Implementation}

When we need to fragment an edge we just use the \texttt{frag\_edge} function [ref. \ref{sec:frag_edge}]
and we update data and store the changes.
While we fragment the edges, we also build a temporary version of \texttt{edge\_map}[ref. \ref{sec:planar_arrangement_intro}]. We do this using \texttt{i}
(the index of the edge that must be fragmented) and the indices of the new edges inside \texttt{ev}
offset by the \texttt{finalcells\_num} counter, which is updated at every step adding the numbers of
fragments created per edge; this counter will also be used later to build the complete 1-skeleton 
edge matrix with ease.

@D Fragment edge
@{v, ev = frag_edge(V, EV, i)

newedges_nums = map(x->x+finalcells_num, collect(1:size(ev, 1)))
edge_map[i] = newedges_nums
finalcells_num += size(ev, 1)

rV, rEV = skel_merge(rV, rEV, v, ev)
@}

We declare \texttt{EVs} and \texttt{finalcells\_num} as local variables of \texttt{planar\_arrangement}.

@D planar\_arrangement local variables
@{rV = zeros(0, 2)
rEV = spzeros(Int8, 0, 0)
finalcells_num = 0
@}


%++++++++++++++++%
\subsection{Tests}
\begin{figure}[h]
    \centering
    \includegraphics{./img/ch2-edgeint.pdf}
    \caption{The bunch of edges used for the tests.}
\end{figure}
@D planar\_arrangement support functions tests
@{@@testset "Edge fragmentation tests" begin
    V = [2 2; 4 2; 3 3.5; 1 3; 5 3; 1 2; 5 2]
    EV = sparse(Array{Int8, 2}([
        [1 1 0 0 0 0 0] #1->12
        [0 1 1 0 0 0 0] #2->23
        [1 0 1 0 0 0 0] #3->13
        [0 0 0 1 1 0 0] #4->45
        [0 0 0 0 0 1 1] #5->67
    ]))

    @@testset "intersect_edges" begin
        inters1 = LARLIB.intersect_edges(V, EV[5, :], EV[1, :])
        inters2 = LARLIB.intersect_edges(V, EV[1, :], EV[4, :])
        inters3 = LARLIB.intersect_edges(V, EV[1, :], EV[2, :])
        @@test inters1 == [([2. 2.], 1/4),([4. 2.], 3/4)]
        @@test inters2 == []
        @@test inters3 == [([4. 2.], 1)]
    end

    @@testset "frag_edge" begin
        rV, rEV = LARLIB.frag_edge(V, EV, 5)
        @@test rV == [1.0 2.0; 5.0 2.0; 2.0 2.0; 4.0 2.0; 4.0 2.0; 2.0 2.0]
        @@test full(rEV) == [1 0 0 0 0 1;
                             0 0 0 0 1 1; 
                             0 1 0 0 1 0]
    end
end
@}









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coincident vertices merge}
\label{sec:2D_merge_vertices}

To merge vertices in $d=2$ the procedure is obviously similar to the one 
used for $d=3$ so we will
reuse some macros already defined [ref. \ref{sec:3D_merge_vertices}]

@D LAR imports
@{using NearestNeighbors
@}

The function is marked with ``\texttt{!}'' in its signature 
because it has collateral effects
on the \texttt{edge\_map} argument; we will for sure modify both
the geometry and the topology of the complex, so \texttt{edge\_map}
must be accordingly updated.

@D planar\_arrangement support functions
@{function merge_vertices!(V::Verts, EV::Cells, edge_map, err=1e-4)
    vertsnum = size(V, 1)
    edgenum = size(EV, 1)
    newverts = zeros(Int, vertsnum)
    kdtree = KDTree(V')

    @< Find coincident vertices @>
    @< Merge edges @>
    @< Update edge\_map after vertex merging @>

    return nV, nEV
end
@}

The last step is to update \texttt{edge\_map}.
We update the indices using the data structures
built in the $\langle$ Merge edges $\rangle$ macro
[ref. \ref{sec:3D_merge_vertices}].

@D Update edge\_map after vertex merging
@{for i in 1:length(edge_map)
    row = edge_map[i]
    row = map(x->edges[x], row)
    row = filter(t->t[1]!=t[2], row)
    row = map(x->etuple2idx[x], row)
    edge_map[i] = row
end
@}


%+++++++++++++++++++++++++%
\subsection{Implementation}
We simply call \texttt{merge\_vertices}.
@D Merge coincident vertices
@{V, EV = merge_vertices!(V, EV, edge_map)
@}
%++++++++++++++++%
\subsection{Tests}
Let's merge the vertices of a square built by numerous
very similar edges.
@D planar\_arrangement support functions tests
@{@@testset "merge_vertices test set" begin
    n0 = 1e-12
    n1l = 1-1e-12
    n1u = 1+1e-12
    V = [ n0  n0; -n0  n0;  n0 -n0; -n0 -n0;
          n0 n1u; -n0 n1u;  n0 n1l; -n0 n1l;
         n1u n1u; n1l n1u; n1u n1l; n1l n1l;
         n1u  n0; n1l  n0; n1u -n0; n1l -n0]
    EV = Int8[1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0;
              0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0;
              0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0;
              0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0;
              0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0;
              0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0;
              0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0;
              0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0;
              0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0;
              0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0;
              0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0;
              0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1;
              1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0;
              0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0;
              0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0;
              0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1]
    EV = sparse(EV)
    V, EV = LARLIB.merge_vertices!(V, EV, [])

    @@test V == [n0 n0; n0 n1u; n1u n1u; n1u n0]
    @@test full(EV) == [1 1 0 0;
                       0 1 1 0;
                       0 0 1 1;
                       1 0 0 1]
end
@}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Delete edges outside $\sigma$ area}

If a face $\sigma$ is passed as input of the planar arrangement,
we need to delete the edges outside the area of $\sigma$. 
First, we use \texttt{edge\_map} to get the fragments of the edges of the original $\sigma$;
then for every edge which is not a fragment of $\sigma$'s edges, we check if its centroid
is inside $\sigma$ using the \texttt{point\_in\_face} utility [ref. \ref{sec:point_in_face}].
Finally, once we have marked the edges to delete, we delete them [ref. \ref{sec:delete_edges}] 
and update the \texttt{edge\_map} (refer to next macro for this).

@D Delete edges outside sigma area
@{if sigma.n > 0
    todel = []
    
    new_edges = []
    map(i->new_edges=union(new_edges, edge_map[i]), sigma.nzind)
    ev = EV[new_edges, :]

    for e in 1:EV.m
        if !(e in new_edges)

            vidxs = EV[e, :].nzind
            v1, v2 = map(i->V[vidxs[i], :], [1,2])
            centroid = .5*(v1 + v2)
            
            if !point_in_face(centroid, V, ev) 
                push!(todel, e)
            end
        end
    end

    @< Update edge\_map @>

    V, EV = delete_edges(todel, V, EV)
end
@}

\label{macro:update_edge_map}
For every deleted edge the \texttt{edge\_map} must be updated. 
So we delete the index of the edge from the mapping and subtract one 
to the indices greater than the index of the deleted edge.


@D Update edge\_map
@{for i in reverse(todel)
    for row in edge_map

        filter!(x->x!=i, row)

        for j in 1:length(row)
            if row[j] > i
                row[j] -= 1
            end
        end
    end
end
@}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Maximal biconnected components}
\begin{figure}[h]
    \centering
    \includegraphics{./img/ch2-bicon.pdf}
    \caption{An example graph where the maximal biconnected 
    components are highlighted in green and the edges are numbered. 
    We have here three components formed by the sets of edges \{1,5,9\}, \{2,6,10\} and \{3,11,7\} }
    \label{img:bicon_comps}
\end{figure}
%+++++++++++++++++++++++++++%
\subsection{Support function}
\label{sec:biconnected_components}
To individuate the maximal biconnected components of the fragmented and merged 1-skeleton
we use the 1973 Hopcroft-Tarjan algorithm for biconnected components\cite{Hopcroft-Tarjan}.
@D planar\_arrangement support functions
@{function biconnected_components(EV::Cells)
    @< biconnected\_components local variables @>
    @< DFS utilities @>
    @< Depth first visit @>
    bicon_comps
end
@}
We will need a point stack (\texttt{ps}), an edge stack (\texttt{es}), a list of traversed edges (\texttt{todel}), a list of 
visited points (\texttt{visited}), a list of biconnected components (\texttt{bicon\_comps}) and a index to avoid duplicate 
numbering of vertices (\texttt{hivtx}). \texttt{ps} is made of triples composed by the index of the vertex in \texttt{V}, 
the index assigned by the algorithm and the component identifier also assigned by the algorithm. \texttt{es} instead 
contains couples with the index of the edge inside \texttt{EV} and the assigned index of the tail node. The indexes 
in \texttt{todel} and \texttt{bicon\_comps} are relative to \texttt{EV} while the ones of \texttt{visited} are
relative to \texttt{V}
@D biconnected\_components local variables
@{ps = Array{Tuple{Int, Int, Int}, 1}()
es = Array{Tuple{Int, Int}, 1}()
todel = Array{Int, 1}()
visited = Array{Int, 1}()
bicon_comps = Array{Array{Int, 1}, 1}()
hivtx = 1
@}
Here are implemented some functions helpful throughout the algorithm.
\texttt{an\_edge} returns the index relative to \texttt{EV} of the first edge out of \texttt{point} if exists or 
\texttt{false} otherwise. \texttt{get\_head}, given an \texttt{edge} and a point (the \texttt{tail}), returns the 
index relative to \texttt{V} of the head (the point that is not \texttt{tail}) of the \texttt{edge}. 
\texttt{v\_to\_vi}, given the index relative to \texttt{V} of a vertex (\texttt{v}), returns its index using 
the algorithm numbering. This index can also not exists; in this case \texttt{false} is returned.
@D DFS utilities
@{function an_edge(point)
    edges = setdiff(EV[:, point].nzind, todel)
    if length(edges) == 0
        edges = [false]
    end
    edges[1]
end

function get_head(edge, tail)
    setdiff(EV[edge, :].nzind, [tail])[1]
end

function v_to_vi(v)
    i = findfirst(t->t[1]==v, ps)
    if i == 0
        return false
    else
        return ps[i][2]
    end
end
@}
The DFS visit is mostly akin to the one proposed in the Hopcroft-Tarjan original algorithm.
The starting point is the first one in \texttt{V}.
@D Depth first visit
@{push!(ps, (1,1,1))
push!(visited, 1)
exit = false
while !exit
    edge = an_edge(ps[end][1])
    if edge != false
        tail = ps[end][2]
        head = get_head(edge, ps[end][1])
        hi = v_to_vi(head)
        if hi == false
            hivtx += 1
            push!(ps, (head, hivtx, ps[end][2]))
            push!(visited, head)
        else
            if hi < ps[end][3]
                ps[end] = (ps[end][1], ps[end][2], hi)
            end
        end
        push!(es, (edge, tail))
        push!(todel, edge)
    else
        if length(ps) == 1
            @< Handle disconnected graph @>
        else
            if ps[end][3] == ps[end-1][2]
                @< Form biconnected component @>
            else
                if ps[end-1][3] > ps[end][3]
                    ps[end-1] = (ps[end-1][1], ps[end-1][2], ps[end][3])
                end
            end
            pop!(ps)
        end
    end
end
@}
To form a biconnected component we pop edges out from the stack of edges (\texttt{es}) until we find the one
of which the index of its tail is equal to the component identifier (called \texttt{LOWPOINT} in the original algorithm) 
of the top point of the point stack (\texttt{ps}). We effectively put inside the \texttt{bicon\_comps} only the components
made of more than one edge because we are interested in building a 1-skeleton of valid 2-cells.
@D Form biconnected component
@{edges = Array{Int, 1}()
while true
    edge, tail = pop!(es)
    push!(edges, edge)
    if tail == ps[end][3]
        if length(edges) > 1
            push!(bicon_comps, edges)
        end
        break
    end
end
@}
When there are no more points to visit in the current connected component we search for a point in \texttt{V}
which has not been visited yet (so a point not listed in the \texttt{visited} array) and we put it on the top
of a new point stack and then let the algorithm iterate again. If there are no more new connected components 
to visit we break the algorithm iteration and exit.
@D Handle disconnected graph
@{found = false
pop!(ps)
for i in 1:size(EV,2)
    if !(i in visited)
        hivtx = 1
        push!(ps, (i, hivtx, 1))
        push!(visited, i)
        found = true
        break
    end
end
if !found
    exit = true
end
@}
%+++++++++++++++++++++++++%
\subsection{Implementation}
Like for the vertices merge we simply call the freshly implemented \texttt{biconnected\_components} function
[ref. \ref{sec:biconnected_components}]. If no biconnected components are found, the procedure will stop and return nothing.
@D Find maximal biconnected components
@{bicon_comps = biconnected_components(EV)

if isempty(bicon_comps)
    println("No biconnected components found.")
    return (nothing, nothing, nothing)
end
@}

We also need to delete edges that are not part of a maximal biconnected component
and then to delete the isolated vertices from both \texttt{V} and \texttt{EV}.
We also update the \texttt{edge\_map} to adapt it to the deletions made (We use the
macro defined in \ref{macro:update_edge_map}).

@D Filter biconnected components
@{
edges = sort(union(bicon_comps...))
todel = sort(setdiff(collect(1:size(EV,1)), edges))

@< Update edge\_map @>

V, EV = delete_edges(todel, V, EV)

@}

%++++++++++++++++%
\subsection{Tests}
The graph built here is the one of figure \ref{img:bicon_comps}.
@D planar\_arrangement support functions tests
@{@@testset "biconnected_components test set" begin
    EV = Int8[0 0 0 1 0 0 0 0 0 0 1 0; #1
              0 0 1 0 0 1 0 0 0 0 0 0; #2
              0 0 0 0 0 0 1 0 0 1 0 0; #3
              1 0 0 0 1 0 0 0 0 0 0 0; #4
              0 0 0 1 0 0 0 1 0 0 0 0; #5
              0 0 1 0 0 0 0 0 1 0 0 0; #6
              0 1 0 0 0 0 0 0 0 1 0 0; #7
              0 0 0 0 1 0 0 0 0 0 0 1; #8
              0 0 0 0 0 0 0 1 0 0 1 0; #9
              0 0 0 0 0 1 0 0 1 0 0 0; #10
              0 1 0 0 0 0 1 0 0 0 0 0; #11
              0 0 0 0 1 0 0 0 0 0 1 0; #12
              0 0 0 0 1 0 0 0 1 0 0 0] #13
    EV = sparse(EV)

    bc = LARLIB.biconnected_components(EV)
    bc = Set(map(Set, bc))

    @@test bc == Set([Set([1,5,9]), Set([2,6,10]), Set([3,7,11])])
end
@}













%%%%%%%%%%%%%%%%%%%%%%%%
\section{Faces creation}
%+++++++++++++++++++++++++%
\subsection{Implementation}
@D Create faces
@{bicon_comps = biconnected_components(EV)

n = size(bicon_comps, 1)
shells = Array{Cell, 1}(n)
boundaries = Array{Cells, 1}(n)
EVs = Array{Cells, 1}(n)
for p in 1:n
    ev = EV[sort(bicon_comps[p]), :]
    fe = minimal_2cycles(V, ev)
    shell_num = get_external_cycle(V, ev, fe)

    EVs[p] = ev 
    tokeep = setdiff(1:fe.m, shell_num)
    boundaries[p] = fe[tokeep, :]
    shells[p] = fe[shell_num, :]
end

@< Containment test @>
@< Transitive reduction @>
@< Cell merging @>

@}

%++++++++++++++++++++++++++++++++++++++++%
\subsection{Individuate the external cell}
Once we computed the minimal 2-cycles [ref. \ref{ch:minimal_cycles}]
we need to individuate the external cycle. To do this we iterate over the
vertices of the passed \texttt{EV} to find four vertices: the two with biggest
$x_1$ and $x_2$ coordinates (\texttt{maxv\_x1} and \texttt{maxv\_x2}) and the 
two with the smallest one (\texttt{minv\_x1} and \texttt{minv\_x2}). 
Then we check which face the two vertices have in common. 

It can happen that the two vertices have more than one face in common
(for example when a biconnected component is made up only by one face);
in this case we simply pick the cell with negative area. The area
computation routines are located into section \ref{sec:face_area},


@D planar\_arrangement support functions
@{function get_external_cycle(V::Verts, EV::Cells, FE::Cells)
    FV = abs.(FE)*EV
    vs = sparsevec(mapslices(sum, abs.(EV), 1)).nzind
    minv_x1 = maxv_x1 = minv_x2 = maxv_x2 = pop!(vs)
    for i in vs
        if V[i, 1] > V[maxv_x1, 1]
            maxv_x1 = i
        elseif V[i, 1] < V[minv_x1, 1]
            minv_x1 = i
        end
        if V[i, 2] > V[maxv_x2, 2]
            maxv_x2 = i
        elseif V[i, 2] < V[minv_x2, 2]
            minv_x2 = i
        end
    end
    cells = intersect(
        FV[:, minv_x1].nzind, 
        FV[:, maxv_x1].nzind,
        FV[:, minv_x2].nzind,
        FV[:, maxv_x2].nzind
    )
    if length(cells) == 1
        return cells[1]
    else
        for c in cells
            if face_area(V, EV, FE[c, :]) < 0
                return c
            end
        end
    end
end
@}

%+++++++++++++++++++++++++++%
\subsection{Containment test}

For each shell we must compute if it is contained
in another shell. So, for every couple of shells
we must check if one is contained into the other.
This check must be performed by shooting a ray from
a vertex of the first cell and then count the intersections
of it with the edges of the second cell; if the number 
of the intersections is odd then the first cell is contained
in the second one. This computation is rather heavy but can be
speeded up by pre-computing an approximate containment graph 
using a bounding box containment test. Then the graph must be
pruned shooting a ray for every arc of it. In this way we reduce
considerably the amount of rays we shoot. This will be also visually
explained in the tests [ref. \ref{sec:conttest_test}].

Before building the containment graph, we
compute the bounding boxes of the shells and we store them into
the \texttt{shell\_bboxes} list (we are going to use this also later).
The bounding box logic is implemented in the utilities
[ref. \ref{sec:bboxes}].

@D Containment test
@{shell_bboxes = []
for i in 1:n
    vs_indexes = (abs.(EVs[i]')*abs.(shells[i])).nzind
    push!(shell_bboxes, bbox(V[vs_indexes, :]))
end

containment_graph = pre_containment_test(shell_bboxes)
containment_graph = prune_containment_graph(n, V, EVs, shells, containment_graph)
@}

@D planar\_arrangement support functions
@{function pre_containment_test(bboxes)
    n = length(bboxes)
    containment_graph = spzeros(Int8, n, n)

    for i in 1:n
        for j in 1:n
            if i != j && bbox_contains(bboxes[j], bboxes[i])
                containment_graph[i, j] = 1
            end
        end
    end

    return containment_graph
end
@}

To check if a point is really inside a face we use the
\texttt{point\_in\_face} utility [ref. \ref{sec:point_in_face}]

@D planar\_arrangement support functions
@{function prune_containment_graph(n, V, EVs, shells, graph)
    
    for i in 1:n
        an_edge = shells[i].nzind[1]
        origin_index = EVs[i][an_edge, :].nzind[1]
        origin = V[origin_index, :]
 
        for j in 1:n
            if i != j
                if graph[i, j] == 1
                    shell_edge_indexes = shells[j].nzind
                    ev = EVs[j][shell_edge_indexes, :]

                    if !point_in_face(origin, V, ev)
                        graph[i, j] = 0
                    end
                end
             end
         end

     end
     return graph
end
@}

%+++++++++++++++++++++++++++++++%
\subsection{Transitive reduction}

We have an adjacency matrix and we must perform a transitive reduction.
As explained by A. V. Aho, M. R. Garey, and J. D. Ullman \cite{transitive_reduction}
we have:

@D Transitive reduction
@{transitive_reduction!(containment_graph) 
@}

@D planar\_arrangement support functions
@{function transitive_reduction!(graph)
    n = size(graph, 1)
    for j in 1:n
        for i in 1:n
            if graph[i, j] > 0
                for k in 1:n
                    if graph[j, k] > 0
                        graph[i, k] = 0
                    end
                end
            end
        end
    end
end
@}

%+++++++++++++++++++++++%
\subsection{Cell merging}

For every arc of the containment tree we have a father component 
and a child component and we must find the cycle of the father that
contains the child. This happens if the bounding box of the child is fully
contained in the box of the cycle\footnote{Please note that
that the \texttt{bboxes} is not part of the bounding box utilities 
[ref. \ref{sec:bboxes}] but it is defined 
in the next paragraph}. The \texttt{sums} array contains the indexes of 
the rows of the various boundary matrices to sum after the containment 
graph has been traversed. Every element is a triple made of: the father 
index, the father's container cell index and the child index.
Once we individuated the rows to sum, we actually need to perform the sum.
This is non trivial because we must build the final boundary matrix.
These computations are delegated to the $\langle$ Create EV and FE $\rangle$ macro.
@D Cell merging 
@{EV, FE = cell_merging(n, containment_graph, V, EVs, boundaries, shells, shell_bboxes)
@}

@D planar\_arrangement support functions 
@{function cell_merging(n, containment_graph, V, EVs, boundaries, shells, shell_bboxes)
    @< Cell merging support functions @>

    sums = Array{Tuple{Int, Int, Int}}(0);

    for father in 1:n
        if sum(containment_graph[:, father]) > 0
            father_bboxes = bboxes(V, abs.(EVs[father]')*abs.(boundaries[father]'))
            for child in 1:n
                if containment_graph[child, father] > 0
                    child_bbox = shell_bboxes[child]
                    for b in 1:length(father_bboxes)
                        if bbox_contains(father_bboxes[b], child_bbox)
                            push!(sums, (father, b, child))
                            break
                        end
                    end
                end            
            end
        end
    end

    @< Create EV and FE @>
    return EV, FE
end
@}

The \texttt{bboxes} computes the bounding boxes of each cycle
described in the \texttt{indexes} matrix.

@D Cell merging support functions
@{function bboxes(V::Verts, indexes::Cells)
    boxes = Array{Tuple{Any, Any}}(indexes.n)
    for i in 1:indexes.n
        v_inds = indexes[:, i].nzind
        boxes[i] = bbox(V[v_inds, :])
    end
    boxes
end
@}

To actually build the complete and correct boundary matrix \texttt{FE},
we compute the final dimensions of it, then we initialize it filled with
zeros and then we fill it with the correct data in the correct position.
While doing this we store into \texttt{c\_offsets} the column offset of each
biconnected component; we will use this information to quickly find the columns 
to sum from the \texttt{sums} array of triples.

@D Create EV and FE
@{EV = vcat(EVs...)
edgenum = size(EV, 1)
facenum = sum(map(x->size(x,1), boundaries))
FE = spzeros(Int8, facenum, edgenum)
shells2 = spzeros(Int8, length(shells), edgenum)
r_offsets = [1]
c_offset = 1
for i in 1:n
    min_row = r_offsets[end]
    max_row = r_offsets[end] + size(boundaries[i], 1) - 1
    min_col = c_offset
    max_col = c_offset + size(boundaries[i], 2) - 1
    FE[min_row:max_row, min_col:max_col] = boundaries[i]
    shells2[i, min_col:max_col] = shells[i]
    push!(r_offsets, max_row + 1)
    c_offset = max_col + 1
end

for (f, r, c) in sums
    FE[r_offsets[f]+r-1, :] += shells2[c, :]
end
@}


%++++++++++++++++%
\subsection{Tests}

@D planar\_arrangement support functions tests
@{@@testset "Face creation" begin
    @< Face creation tests @>
end
@}

\subsubsection{External cell individuation}
\begin{figure}[h]
    \centering
    \includegraphics{./img/ch2-externcell.pdf}
    \caption{This biconnected component has three faces. The external one is the number 3.
    This is a particularly difficult case because the most "external" vertices of face 2
    are in common with the external cell.}
\end{figure}

@D Face creation tests
@{@@testset "External cell individuation" begin
    V = [ .5 .5;  1.5   1;  1.5  2; 
         2.5  2;  2.5   1;  3.5 .5;
         3.5  3;    2 2.5;   .5  3]

    EV = Int8[-1  1  0  0  0  0  0  0  0;
               0 -1  1  0  0  0  0  0  0;
               0  0 -1  1  0  0  0  0  0;
               0  0  0 -1  1  0  0  0  0;
               0  0  0  0 -1  1  0  0  0;
               0  0  0  0  0 -1  1  0  0;
               0  0  0  0  0  0 -1  1  0;
               0  0  0  0  0  0  0 -1  1;
              -1  0  0  0  0  0  0  0  1;
               0 -1  0  0  1  0  0  0  0]
    EV = sparse(EV)
    
    FE = Int8[ 0 -1 -1 -1  0  0  0  0  0  1;
               1  1  1  1  1  1  1  1 -1  0;
              -1  0  0  0 -1 -1 -1 -1  1 -1]
    FE = sparse(FE)

    @@test LARLIB.get_external_cycle(V, EV, FE) == 3
end
@}

\subsubsection{Containment test}
\label{sec:conttest_test}

\begin{figure}[h]
    \centering
    \includegraphics{./img/ch2-containmenttest.pdf}
    \caption{(a) is our test case. The numbers identify the connected components. 
        (b) is the containment graph built using only the \texttt{pre\_containment\_test} 
        function. The arc (4,5) is in there because the bounding box of the component 
        no. 5 is completely contained in the bounding box of no. 4. (c) shows 
        the graph after the \texttt{prune\_containment\_graph} function.}
\end{figure}

@D Face creation tests
@{@@testset "Containment test" begin
    V = [  0   0;    4   0;    4   2;   2   4;  0 4;
          .5  .5;  2.5  .5;  2.5 2.5;  .5 2.5;
           1   1;  1.5   1;    1   2;
           2   1;    2   2;  1.5   2;
         3.5 3.5;    3 3.5;  3.5   3]
    EV1 = Int8[ 0  0  0  0  0  0  0  0  0 -1  1  0  0  0  0  0  0  0;
                0  0  0  0  0  0  0  0  0  0 -1  1  0  0  0  0  0  0;
                0  0  0  0  0  0  0  0  0 -1  0  1  0  0  0  0  0  0]
    EV2 = Int8[ 0  0  0  0  0  0  0  0  0  0  0  0 -1  1  0  0  0  0;
                0  0  0  0  0  0  0  0  0  0  0  0  0 -1  1  0  0  0;
                0  0  0  0  0  0  0  0  0  0  0  0 -1  0  1  0  0  0]
    EV3 = Int8[ 0  0  0  0  0 -1  1  0  0  0  0  0  0  0  0  0  0  0;
                0  0  0  0  0  0 -1  1  0  0  0  0  0  0  0  0  0  0;
                0  0  0  0  0  0  0 -1  1  0  0  0  0  0  0  0  0  0;
                0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0]
    EV4 = Int8[-1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0;
                0 -1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0;
                0  0 -1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0;
                0  0  0 -1  1  0  0  0  0  0  0  0  0  0  0  0  0  0;
               -1  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0]
    EV5 = Int8[ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  1  0;
                0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  1;
                0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  0  1]
    EVs = map(sparse, [EV1, EV2, EV3, EV4, EV5])
    
    shell1 = Int8[-1 -1  1];
    shell2 = Int8[-1 -1  1];
    shell3 = Int8[-1 -1 -1  1];
    shell4 = Int8[-1 -1 -1 -1  1];
    shell5 = Int8[-1 -1  1];
    shells = map(sparsevec, [shell1, shell2, shell3, shell4, shell5])
    
    shell_bboxes = []
    n = 5
    for i in 1:n
        vs_indexes = (abs.(EVs[i]')*abs.(shells[i])).nzind
        push!(shell_bboxes, LARLIB.bbox(V[vs_indexes, :]))
    end

    graph = LARLIB.pre_containment_test(shell_bboxes)
    @@test graph == [0 0 1 1 0; 0 0 1 1 0; 0 0 0 1 0; 0 0 0 0 0; 0 0 0 1 0]

    graph = LARLIB.prune_containment_graph(n, V, EVs, shells, graph)
    @@test graph == [0 0 1 1 0; 0 0 1 1 0; 0 0 0 1 0; 0 0 0 0 0; 0 0 0 0 0]
end
@}

\subsubsection{Transitive reduction}
\label{sec:transitivered_test}

\begin{figure}[h]
    \centering
    \includegraphics{./img/ch2-transitivered.pdf}
    \caption{Before (a) and after (b) transitive reduction performed on
    the graph of the previous test set.}
\end{figure}

@D Face creation tests
@{@@testset "Transitive reduction" begin
    graph = [0 0 1 1 0; 0 0 1 1 0; 0 0 0 1 0; 0 0 0 0 0; 0 0 0 0 0]
    LARLIB.transitive_reduction!(graph)
    @@test graph == [0 0 1 0 0; 0 0 1 0 0; 0 0 0 1 0; 0 0 0 0 0; 0 0 0 0 0]
end
@}

\subsubsection{Cell merging}

\begin{figure}[h]
    \centering
    \includegraphics{./img/ch2-cellmerge.pdf}
    \caption{Here we have two biconnected components, one inside the other (a).
    If we don't perform cell merging, the boundary of the arranged set will be
    the red one (b), which is incorrect. The correct boundary is the blue one (c).}
\end{figure}

@D Face creation tests
@{@@testset "Cell merging" begin
    graph = [0 1; 0 0]
    V = [.25 .25; .75 .25; .75 .75; .25 .75;
           0   0;   1   0;   1   1;   0   1]
    EV1 = Int8[-1  1  0  0  0  0  0  0;
                0 -1  1  0  0  0  0  0;
                0  0 -1  1  0  0  0  0;
               -1  0  0  1  0  0  0  0;
               -1  0  1  0  0  0  0  0]
    EV2 = Int8[ 0  0  0  0 -1  1  0  0;
                0  0  0  0  0 -1  1  0;
                0  0  0  0  0  0 -1  1;
                0  0  0  0 -1  0  0  1]
    EVs = map(sparse, [EV1, EV2])

    shell1 = Int8[-1 -1 -1  1  0]
    shell2 = Int8[-1 -1 -1  1]
    shells = map(sparsevec, [shell1, shell2])

    boundary1 = Int8[ 1  1  0  0 -1;
                      0  0  1 -1  1]
    boundary2 = Int8[ 1  1  1 -1]
    boundaries = map(sparse, [boundary1, boundary2])

    shell_bboxes = []
    n = 2
    for i in 1:n
        vs_indexes = (abs.(EVs[i]')*abs.(shells[i])).nzind
        push!(shell_bboxes, LARLIB.bbox(V[vs_indexes, :]))
    end

    EV, FE = LARLIB.cell_merging(2, graph, V, EVs, boundaries, shells, shell_bboxes)

    selector = sparse(ones(Int8, 1, 3))

    @@test selector*FE == [0  0  0  0  0  1  1  1 -1]
end
@}


%%%%%%%%%%%%%%%%%%%%%%%%
\section{General examples}
\label{sec:planar_arrangement_examples}

@D planar\_arrangement general examples
@{function generate_perpendicular_lines(steps::Int, minlen, maxlen)
    V = zeros(0,2)

    function rec(o, d, s)
        if s == 0 return end

        a = (maxlen-minlen)*rand() + minlen
        p = o + a*d
        V = [V; o; p]

        b = (a-minlen)*rand() + minlen
        p = o + b*d
        rec(p, d, s-1)

        b = (a-minlen)*rand() + minlen
        p = o + b*d
        rec(p, perpendicular(d), s-1)
    end

    function perpendicular(vec)
        v = zeros(size(vec))
        v[1] = vec[2]
        v[2] = vec[1]
        return v
    end

    rec([0 0], [1 0], steps)
    rec([0 0], [0 1], steps)
    vnum = size(V, 1)
    enum = vnum >> 1
    EV = spzeros(Int8, enum, vnum)
    for i in 1:enum
        EV[i, i*2-1:i*2] = 1
    end
    V, EV
end


function generate_random_lines(n, points_range, alphas_range)
    origins = points_range[1] + (points_range[2]-points_range[1])*rand(n, 2)
    directions = mapslices(normalize, rand(n, 2) - .5*ones(n, 2), 2)
    alphas = alphas_range[1] + (alphas_range[2]-alphas_range[1])*rand(n)
    new_points = Array{Float64, 2}(n, 2)
    for i in 1:n
        new_points[i, :] = origins[i, :] + alphas[i]*directions[i, :]
    end
    V = [origins; new_points]
    EV = spzeros(Int8, n, n*2)
    for i in 1:n
        EV[i, i] = 1
        EV[i, n+i] = 1
    end
    V, EV
end
@}

\vfill

\begin{figure}[p!]
    \includegraphics[width=\textwidth]{./img/test-lines.pdf}%
    \caption{Input}
\end{figure}


\begin{figure}[p!]
    \includegraphics[width=\textwidth]{./img/test-lines-out-compact.pdf}%
    \caption{Output}
\end{figure}

\begin{figure}[p!]
    \includegraphics[width=\textwidth]{./img/test-lines-out.pdf}%
    \caption{Output (Exploded)}
\end{figure}