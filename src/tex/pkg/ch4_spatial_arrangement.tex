\chapter{Spatial Arrangement}

\textbf{THIS IS A WORK IN PROGRESS. DO NOT USE.}

%%%%%%%%%%%%%%%%%%
\section{Overview}
Here we present the spatial arrangement algorithm. 

@O lib/jl/spatial_arrangement.jl
@{@< spatial\_arrangement imports @>
@< spatial\_arrangement support functions @>

function spatial_arrangement(V::Verts, EV::Cells, FE::Cells)
    vs_num = size(V, 1)
    es_num = size(EV, 1)
    fs_num = size(FE, 1)

    sp_idx = spatial_index(V, EV, FE)

    rV = Verts(0,3)
    rEV = spzeros(Int8,0,0)
    rFE = spzeros(Int8,0,0)

    for sigma in 1:fs_num
        sigmavs = (abs(FE[sigma:sigma,:])*abs(EV))[1,:].nzind 
        sV = V[sigmavs, :]
        sEV = EV[FE[sigma, :].nzind, sigmavs]


        M = submanifold_mapping(sV[1,:], sV[2,:], sV[3,:])
        tV = ([V ones(vs_num)]*M)[:, 1:3]

        sV = tV[sigmavs, :]

        for i in sp_idx[sigma]
            tmpV, tmpEV = face_int(tV, EV, FE[i, :])
            
            sV, sEV = skel_merge(sV, sEV, tmpV, tmpEV)
        end

        sV = sV[:, 1:2]

        println("SIGMA: ", sigma)
        
        nV, nEV, nFE = planar_arrangement(sV, sEV, sparsevec(ones(Int8, length(sigmavs))))

        nvsize = size(nV, 1)
        nV = [nV zeros(nvsize) ones(nvsize)]*inv(M)[:, 1:3]

        rV, rEV, rFE = skel_merge(rV, rEV, rFE, nV, nEV, nFE)
    end

    rV, rEV, rFE = merge_vertices(rV, rEV, rFE)
    
    for i in 1:rEV.m
        j = min(rEV[i,:].nzind...)
        rEV[i, j] = -1
    end

    return rV, rEV, rFE
end


@}
We include the utilities (ref. \ref{ch:utilities}).
@D spatial\_arrangement imports
@{
include("./utilities.jl")
include("./planar_arrangement.jl")
include("./dimension_travel.jl")
@}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coincident vertices merge}
\label{sec:3D_merge_vertices}
Even in $d=3$ we need to merge coincident vertices.
The procedure is obviously similar to the one for $d=2$ so we will
reuse some macros already defined (ref. \ref{sec:2D_merge_vertices})

@D spatial\_arrangement imports
@{using NearestNeighbors
@}
@D spatial\_arrangement support functions
@{function merge_vertices(V::Verts, EV::Cells, FE::Cells, err=1e-4)
    vertsnum = size(V, 1)
    edgenum = size(EV, 1)
    facenum = size(FE, 1)
    newverts = zeros(Int, vertsnum)
    kdtree = KDTree(V')

    @< Find coincident vertices @>
    @< Merge edges @>
    @< Merge faces @>

    return nV, nEV, nFE
end
@}

@D Merge faces
@{faces = [[
    map(x->newverts[x], FE[fi, ei] > 0 ? oedges[ei] : reverse(oedges[ei]))
    for ei in FE[fi, :].nzind
] for fi in 1:facenum]

nfaces = map(collect, union(map(x->Set(x), faces)))

nfacenum = length(nfaces)
nFE = spzeros(Int8, nfacenum, size(nEV, 1))

for fi in 1:nfacenum
    for edge in nfaces[fi]
        ei = etuple2idx[Tuple{Int, Int}(sort(collect(edge)))]
        nFE[fi, ei] = sign(edge[2] - edge[1])
    end
end
@}
