\chapter{Spatial Arrangement}

\textbf{THIS IS A WORK IN PROGRESS. DO NOT USE.}

%%%%%%%%%%%%%%%%%%
\section{Overview}
Here we present the spatial arrangement algorithm. 

@O lib/jl/spatial_arrangement.jl
@{@< spatial\_arrangement imports @>
@< spatial\_arrangement support functions @>

function spatial_arrangement(V::Verts, EV::Cells, FE::Cells)
    vs_num = size(V, 1)
    es_num = size(EV, 1)
    fs_num = size(FE, 1)

    sp_idx = spatial_index(V, EV, FE)

    rV = Verts(0,3)
    rEV = spzeros(Int8,0,0)
    rFE = spzeros(Int8,0,0)

    for sigma in 1:fs_num
        sigmavs = (abs(FE[sigma:sigma,:])*abs(EV))[1,:].nzind 
        sV = V[sigmavs, :]
        sEV = EV[FE[sigma, :].nzind, sigmavs]

        @< Sigma flattening @>

        #=
        if sigma == 5
            visualize_numbers((sV, sEV, []), .6)
        end
        =#

        nV, nEV, nFE = planar_arrangement(sV, sEV, sparsevec(ones(Int8, length(sigmavs))))

        #=
        if sigma == 5
            visualize_numbers((nV, nEV, nFE), .6)
        end
        =#

        nvsize = size(nV, 1)
        nV = [nV zeros(nvsize) ones(nvsize)]*inv(M)[:, 1:3]

        rV, rEV, rFE = skel_merge(rV, rEV, rFE, nV, nEV, nFE)
    end

    rV, rEV, rFE = merge_vertices(rV, rEV, rFE)

    return rV, rEV, rFE
end

@}

We include the utilities (ref. \ref{ch:utilities}).

@D spatial\_arrangement imports
@{
include("./utilities.jl")
include("./planar_arrangement.jl")
include("./dimension_travel.jl")
@}


@D Sigma flattening
@{M = submanifold_mapping(sV[1,:], sV[2,:], sV[3,:])
tV = ([V ones(vs_num)]*M)[:, 1:3]

sV = tV[sigmavs, :]

for i in sp_idx[sigma]
    tmpV, tmpEV = face_int(tV, EV, FE[i, :])
    
    sV, sEV = skel_merge(sV, sEV, tmpV, tmpEV)
end

sV = sV[:, 1:2]
@}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coincident vertices merge}
\label{sec:3D_merge_vertices}
Even in $d=3$ we need to merge coincident vertices.
The procedure is obviously similar to the one for $d=2$ so we will
reuse some macros already defined (ref. \ref{sec:2D_merge_vertices})

@D spatial\_arrangement imports
@{using NearestNeighbors
@}
@D spatial\_arrangement support functions
@{function merge_vertices(V::Verts, EV::Cells, FE::Cells, err=1e-4)
    vertsnum = size(V, 1)
    edgenum = size(EV, 1)
    facenum = size(FE, 1)
    newverts = zeros(Int, vertsnum)
    kdtree = KDTree(V')

    @< Find coincident vertices @>
    @< Merge edges @>
    @< Merge faces @>

    return nV, nEV, nFE
end
@}

We are in $d=3$ so we need to merge also faces.
At the beginning of the procedure we convert the faces into a lists of
edges (represented as a couple of vertices). We then remove duplicated faces
by checking the faces using the same vertices. At the end, we use the
maps built during vertices and edges merge to rebuild the \texttt{FE}
matrix correctly using the new vertex indices.

@D Merge faces
@{faces = [[
    map(x->newverts[x], FE[fi, ei] > 0 ? oedges[ei] : reverse(oedges[ei]))
    for ei in FE[fi, :].nzind
] for fi in 1:facenum]


visited = []
function filter_fn(face)

    verts = []
    map(e->verts = union(verts, collect(e)), face)
    verts = Set(verts)

    if !(verts in visited)
        push!(visited, verts)
        return true
    end
    return false
end

nfaces = filter(filter_fn, faces)

println(nfaces)

nfacenum = length(nfaces)
nFE = spzeros(Int8, nfacenum, size(nEV, 1))

for fi in 1:nfacenum
    for edge in nfaces[fi]
        ei = etuple2idx[Tuple{Int, Int}(sort(collect(edge)))]
        nFE[fi, ei] = sign(edge[2] - edge[1])
    end
end
@}
