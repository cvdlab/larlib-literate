\chapter{Module overview}

@O lib/jl/LARLIB.jl
@{module LARLIB

    @< LAR imports @>
    @< LAR types @>

    include("./utilities.jl")
    include("./minimal_cycles.jl")
    include("./dimension_travel.jl")
    include("./planar_arrangement.jl")
    include("./spatial_arrangement.jl")
    include("./largrid.jl")
    
end
@}

%%%%%%%%%%%%%%%
\section{Standard types}

We define at the top of our module the standard types
that will be used throughout LAR. As already explained
in the introduction [ref. \ref{sec:LAR}], LAR needs
only one bi-dimensional array to store geometry and 
one or more sparse matrices for topology.
Julia has already implemented CSC sparse matrices in
its standard library so we are going to use them.

@D LAR types
@{const Verts = Array{Float64, 2}
const Cells = SparseMatrixCSC{Int8, Int}
const Cell = SparseVector{Int8, Int}
@}

We used the general name \texttt{Cells}, but
we are going to use this type also for boundaries.

\subsection{Floating point error}
\label{sec:floating-point_error}

We stored geometry using 64-bit IEEE floats.
As it is known, floating point arithmetic is not
precise and introduces numerical errors.
Usually this is not an issue\footnote{The \textit{machine epsilon},
which is the upper bound on the relative error in floating-point 
arithmetic, for double precision IEEE floating-point numbers is 
$2^53 \approx 1.11 \times 10^{-16}$.}, but when precision is
a goal, floating point error must be handled very carefully.
During the development we encountered several numerical problems
and we tried various approaches (like normalizing the geometry
inside the $[0, 1]$ interval for each dimension in order to maximize
the significand of the floating-point numbers) but most of them turned 
out to be unstable. So we choose the less orthodox path we could
possibly take: we set a fixed error and we performed every floating point
comparison using this error. Examples of this ``tweak'' are to be found in
\ref{sec:intersect_edges}, \ref{sec:face_int}, \ref{sec:3d_minimal_cycles} and 
\ref{sec:vertex_equality}.

%%%%%%%%%%%%%%%%%
\section{Notes on variables names}

Here a list of some often used variable names.

\begin{description}[align=right,labelwidth=2em]
    \item [\texttt{V}:]
        Bi-dimensional array (\texttt{Verts}) that keeps the geometry of a complex.
        Its dimensions are $n \times d$, where $n$ is the number of vertices and $d$ is the dimension
        of the euclidean space in which the complex is embedded.
    \item [\texttt{EV}:]
        1-boundary. It is a $m \times n$ sparse matrix (\texttt{Cells}) 
        where $m$ is the number of edges and $n$ is the number of vertices. The possible values
        are $0, 1$ and $-1$.
    \item [\texttt{FE}:]
        2-boundary. Same as \texttt{EV}, but faces on the rows and edges on the columns.
    \item [\texttt{CF}:]
        3-boundary. Same as \texttt{EV}, but 3-cells on the rows and faces on the columns.
\end{description}

%%%%%%%%%%%%%%%
\section{Tests and examples}

There are several unit tests throughout the implementation. They
are inside the \texttt{test} directory and can be run at once
by executing \texttt{test/runtests.jl}

@O test/jl/runtests.jl
@{using LARLIB

include("./planar_arrangement.jl")
include("./dimension_travel.jl")
include("./largrid.jl")
include("./utilities.jl")
@}

Also general examples of some main functionalities are provided.
They can be found into \texttt{examples/general\_examples.jl}

@O examples/jl/general_examples.jl
@{using LARLIB

@< planar\_arrangement general examples @>
@< spatial\_arrangement general examples @>
@}