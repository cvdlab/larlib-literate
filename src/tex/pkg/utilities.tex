\documentclass[10pt,oneside]{article}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\hypersetup{colorlinks = true}

\author{Alberto Paoluzzi, Francesco Furiani, Giulio Martella}
\title{Utilities
\footnote{This document is part of the \emph{Linear Algebraic Representation} (LAR.jl) framework.}
}

\begin{document}
\maketitle
\newpage

%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%
The \texttt{utilities.jl} script file contains various function useful throughout the LAR framework.
@O lib/jl/utilities.jl
@{@< Imports and aliases @>
@< Skeletal union @>
@< Bounding box computation @>
@< Compute spatial index @>
@< Segment-plane intersection @>
@< Face-plane intersection @>
@< Submanifold mapping @>
@}
We define some type aliases to define the default vay to store data.
Please note that we use the Julia's default CSC sparse matrices implementation
to store cells.
%####################%
@D Imports and aliases
@{typealias Verts Array{Float64,2}
typealias Cells SparseMatrixCSC{Int8,Int64}
typealias Cell SparseVector{Int8,Int64}
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Combinatorial union of $(d-1)$-cells}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This function converts cellular complexes into a bidimensional array \texttt{V} of 
vertices and a CSC sparse matrix \texttt{CV} of cells. The input must be an array of complexes
in which the vertices are expressed as a bidimensional array and the cells as a BRC
sparse matrix.
%###############%
@D Skeletal union
@{function skel_union(Xs)
    d = size(Xs[1][1], 2)
    @< Compute V and the BRC sparse matrix @>
    @< Build CV, the CSC sparse matrix @>
    V,CV
end
@}
%####################################%
@D Compute V and the BRC sparse matrix
@{V = Verts(0,d)
BRC = Array{Array{Int64, 1}, 1}()
for h = 1:size(Xs,1)
    BRC = vcat(BRC, Xs[h][2] + size(V,1))
    V = vcat(V, Xs[h][1])
end
@}
%################################%
@D Build CV, the CSC sparse matrix
@{n = length(BRC)
m = size(V,1)
CV = spzeros(Int8, n,m)
for c in 1:n
    cell = BRC[c]
    for i in 1:length(cell)
        CV[c, cell[i]] = 1
    end
end
@}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cell bounding boxes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The function to compute the bounding box of a cell
is pretty straightforward.
%#########################%
@D Bounding box computation
@{function bbox(V::Verts, cell::Cell)
    d = size(V,2)
    VS = Verts(0,d)
    for i in cell.nzind
        VS = vcat(VS, reshape(V[i, :], 1, 2))
    end
    
    lower = mapslices(x->min(x...), VS, 1)
    upper = mapslices(x->max(x...), VS, 1)
    
    lower, upper
end
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Spatial index computation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The aim of this function is to compute a \textit{spatial index} that maps
each cell to a set of cells which it may collide with.
This is achieved by profuse use of bounding boxes and interval trees. 
These last ones are implemented with the \texttt{IntervalTrees.jl} package
(\url{https://github.com/BioJulia/IntervalTrees.jl})
%####################%
@D Imports and aliases
@{using IntervalTrees
@}
%######################%
@D Compute spatial index
@{function spatial_index(V::Verts, CV::Cells)
    d = size(V,2)
    cell_num = size(CV, 1)
    @< Build the d-IntervalTrees @>
    @< Create the mapping @>
    mapping
end
@}
The basic idea is to "unfold" every $d$-dimensional bounding box into $d$ one-dimensional boxes.
To do so, one interval tree per dimension must be created. 
We build the $d$-trees by firstly building the intervals for each box and then the trees.
In this way we keep in memory the \texttt{boxes1D} array (which contains the intervals) for later use.
%##########################%
@D Build the d-IntervalTrees
@{IntervalsType = IntervalValue{Float64, Int64}
boxes1D = Array{IntervalsType, 2}(0, d)
for ci in 1:cell_num
    intervals = map((l,u)->IntervalsType(l,u,ci), bbox(V,CV[ci, :])...)
    boxes1D = vcat(boxes1D, intervals)
end
trees = mapslices(IntervalTree{Float64, IntervalsType}, sort(boxes1D, 1), 1)
@}
The \textit{spatial index} is returned as an array of \texttt{Int64} arrays.
The \texttt{intersect\_intervals} function returns every cell of which its bounding box collides with 
the $d$-intervals passed as argument. This function then is called for the $d$-intervals (stored in the \texttt{boxes1D} array) of every cell.
Obviously every cell collides with itself, so a set difference is performed for every cell to exclude itself from the mapping.
%###################%
@D Create the mapping
@{function intersect_intervals(intervals)
    cells = Array{Int64,1}[]
    for axis in 1:d
        vs = map(i->i.value, intersect(trees[axis], intervals[axis]))
        push!(cells, vs)
    end
    mapreduce(x->x, intersect, cells)
end

mapping = Array{Int64,1}[]
for ci in 1:cell_num
    cell_indexes = setdiff(intersect_intervals(boxes1D[ci, :]), [ci])
    push!(mapping, cell_indexes)
end
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Segment-plane intersection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We want to find the intersection between the segment defined by the vertices $A$ and $B$ ($A, B \in \mathbb{E}^3$) and the plane $x_3=0$.
So we need to find the intersection between two lines:
\[ P=A+\alpha\overrightarrow{AB}, \quad \alpha \in [0,1] \]
\[ P=A'+\beta\overrightarrow{A'B'}, \quad \beta \in [0,1] \]
Where $A'$ and $B'$ are the projections of $A$ and $B$ on the $x_3=0$ plane. \\
If we resolve for $\alpha$ we find out that there is an intersection only if:
\[ \alpha = \frac{x^A_3}{x^B_3 - x^A_3} \in [0,1]\]
@D Segment-plane intersection
@{function seg_plane_int(V::Verts, seg::Cell)
    xa, ya, za, xb, yb, zb = vcat(map(c->V[c, :], seg.nzind)...)
    alpha = za / (za - zb)
    if 0 <= alpha <= 1
        A = [xa ya za]
        B = [xb yb zb]
        return A+alpha*(B-A)
    end
    false
end
@}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Face-plane intersection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This function finds the segments of the intersection of a face with the $x_3=0$ plane.
@D Face-plane intersection
@{function face_plane_int(V::Verts, face::Cells)
    @< Find edges-plane intersections @>
    @< Build the alphas map @>
    @< Put intersections into rV @>
    @< Build the EV matrix @>
    rV, EV
end
@}
First of all, the intersection vertices of the edges of the face with the $x_3=0$ plane are found and stacked in the \texttt{ints} array:
%###############################â…œ
@D Find edges-plane intersections
@{edgenum = size(face, 1)
ints = Array{Verts, 1}()
for e in 1:edgenum
    inter = seg_plane_int(V3, face[e, :])
    if inter != false
        push!(ints, inter)
    end
end
@}
The intersections are then parameterized over the line on which all the intersection lay (the input face is for sure planar).
The data is put into the \texttt{ints\_dict} dictionary.
%#####################%
@D Build the alphas map
@{v = ints[2]-ints[1]
beta = 1/dot(v, v')
ints_dict = Dict{Float64, Verts}()
map(i->ints_dict[beta*dot(v', (i-ints[1]))] = i, ints)
@}
The \texttt{rV} vertices matrix is built up by sorting the keys of \texttt{ints\_dict} and put the intersection points in that order.
Please notice that vertices in \texttt{V} are in $\mathbb{E}^3$ while the ones into \texttt{rV} are in $\mathbb{E}^2$ because
their last coordinate is truncated.
%##########################%
@D Put intersections into rV
@{rV = Verts(0, 2)
map(k->rV=vcat(rV, ints_dict[k][:, 1:2]), sort(collect(keys(ints_dict))))
@}
The \texttt{EV} edges matrix structure is straightforward:
\[
    \texttt{EV} = 
    \begin{pmatrix}
        1 & 1 & 0 & 0 & \cdots & 0 & 0 \\
        0 & 0 & 1 & 1 & \cdots & 0 & 0 \\
        \vdots & \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
        0 & 0 & 0 & 0 & \cdots & 1 & 1
    \end{pmatrix}
\]
%####################%
@D Build the EV matrix
@{ncols = size(rV, 1)
nrows = Int(ncols/2)
EV = spzeros(Int8, nrows, ncols)
map(row->EV[row, 2*row-1:2*row] = 1, 1:nrows)
@}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Submanifold mapping}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This function returns the direct and inverse affine transformation that flattens the given \texttt{face} in $\mathbb{E}^3$
on the plane $x_3=0$. We have two planes: the one on which the input \texttt{face} lays and the $x_3=0$ one. 
We use the three points of the face to compute the coordinate system of the plane which is parallel 
to the \texttt{face} and passes through the origin. This coordinate system is inverted and then used as 
the transformation that makes the \texttt{face} parallel to $x_3=0$. Then this transformation is applied to the 
first point of the \texttt{face} to calculate the translation needed to lay the \texttt{face} perfectly on $x_3=0$.
Both direct and inverse matrices are returned to avoid computing the inverse later.
@D Submanifold mapping
@{function submanifold_mapping(V::Verts,face::Cell)
    p1, p2, p3 = map(i->V[face.nzind[i], :], 1:3)
    u1 = p2-p1
    u2 = p3-p1
    u3 = cross(u1, u2)
    minv = eye(4)
    minv[1:3, 1:3] = [u1 u2 u3]
    m = inv(minv)
    tz = -(m*[p1;1])[3]
    mt = eye(4)
    mt[3,4] = tz
    m = mt*m
    mt[3,4] = -tz
    minv = minv*mt
    m, minv
end
@}


%%%%%%%%%%%%%%%%%
\section{Testing}
%%%%%%%%%%%%%%%%%
@O test/jl/utilities.jl
@{using Base.Test
include("../../lib/jl/utilities.jl")

Xs = (
    [[[1 2];[3 2]],[[1,2]]],
    [[[1 3];[2 1]],[[1,2]]],
    [[[2 3];[3 1]],[[1,2]]],
    [[[1.5 1];[2.5 3]],[[1,2]]]
)

V,CV = skel_union(Xs)

@@testset "skel_union test" begin
    @@test V == [[1 2];[3 2];[1 3];[2 1];[2 3];[3 1];[1.5 1];[2.5 3]]
    @@test full(CV) == [
        [1 1 0 0 0 0 0 0]
        [0 0 1 1 0 0 0 0]
        [0 0 0 0 1 1 0 0]
        [0 0 0 0 0 0 1 1]
    ]
end

lower, upper = bbox(V, CV[2, :])
@@testset "bbox test" begin
    @@test lower == [1 1]
    @@test upper == [2 3]
end

mapping = spatial_index(V,CV)
@@testset "spatial_index test" begin
    @@test mapping == [[2,4,3], [1,4,3], [2,1,4], [2,1,3]]
end

V3 = [0 0 -2; 0 0 2; 1.5 1.5 -1; 3 3 2; 3 3 -2]
FV = sparse(Int8[
    [1 1 0 0 0]
    [0 0 0 1 1]
    [0 0 1 1 0]
    [0 1 1 0 0]
    [1 0 0 0 1]
])
rV, rEV = face_plane_int(V3, FV)
@@testset "face_plane_int test" begin
    @@test rV == [0. 0; 1 1; 2 2; 3 3]
    @@test full(rEV) == [
        [1 1 0 0]
        [0 0 1 1]
    ]
end

V = rand(3, 3)
face = sparsevec(Int8[1 1 1])
m, minv = submanifold_mapping(V, face)
err = 1e-10 
@@testset "submanifold_mapping test" begin
    @@test any(map((x,y)->-err<x-y<err, m*minv, eye(4)))
    @@test any(x->-err<x<err, ([V [1; 1; 1]]*m')[:, 3])
end
@}
\end{document}