\documentclass[10pt,oneside]{article}
\usepackage{hyperref}
\usepackage{amsmath}
\hypersetup{colorlinks = true}

\author{Alberto Paoluzzi, Francesco Furiani, Giulio Martella}
\title{Utilities
\footnote{This document is part of the \emph{Linear Algebraic Representation} (LAR.jl) framework.}
}

\begin{document}
\maketitle
\newpage

%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%
The \texttt{utilities.jl} script file contains various function useful throughout the LAR framework.
@O lib/jl/utilities.jl
@{@< Imports and aliases @>
@< Skeletal union @>
@< Bounding box computation @>
@< Compute spatial index @>
@< Segment-plane intersection @>
@< Face-plane intersection @>
@}
We define some type aliases to define the default vay to store data.
Please note that we use the Julia's default CSC sparse matrices implementation
to store cells.
%####################%
@D Imports and aliases
@{typealias Verts Array{Float64,2}
typealias Cells SparseMatrixCSC{Int8,Int64}
typealias Cell SparseVector{Int8,Int64}
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Combinatorial union of $(d-1)$-cells}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This function converts cellular complexes into a bidimensional array \texttt{V} of 
vertices and a CSC sparse matrix \texttt{CV} of cells. The input must be an array of complexes
in which the vertices are expressed as a bidimensional array and the cells as a BRC
sparse matrix.
%###############%
@D Skeletal union
@{function skel_union(Xs)
    d = size(Xs[1][1], 2)
    @< Compute V and the BRC sparse matrix @>
    @< Build CV, the CSC sparse matrix @>
    V,CV
end
@}
%####################################%
@D Compute V and the BRC sparse matrix
@{V = Verts(0,d)
BRC = Array{Array{Int64, 1}, 1}()
for h = 1:size(Xs,1)
    BRC = vcat(BRC, Xs[h][2] + size(V,1))
    V = vcat(V, Xs[h][1])
end
@}
%################################%
@D Build CV, the CSC sparse matrix
@{n = length(BRC)
m = size(V,1)
CV = spzeros(Int8, n,m)
for c in 1:n
    cell = BRC[c]
    for i in 1:length(cell)
        CV[c, cell[i]] = 1
    end
end
@}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cell bounding boxes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The function to compute the bounding box of a cell
is pretty straightforward.
%#########################%
@D Bounding box computation
@{function bbox(V::Verts, cell::Cell)
    d = size(V,2)
    VS = Verts(0,d)
    for i in cell.nzind
        VS = vcat(VS, reshape(V[i, :], 1, 2))
    end
    
    lower = mapslices(x->min(x...), VS, 1)
    upper = mapslices(x->max(x...), VS, 1)
    
    lower, upper
end
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Spatial index computation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The aim of this function is to compute a \textit{spatial index} that maps
each cell to a set of cells which it may collide with.
This is achieved by profuse use of bounding boxes and interval trees. 
These last ones are implemented with the \texttt{IntervalTrees.jl} package
(\url{https://github.com/BioJulia/IntervalTrees.jl})
%####################%
@D Imports and aliases
@{using IntervalTrees
@}
%######################%
@D Compute spatial index
@{function spatial_index(V::Verts, CV::Cells)
    d = size(V,2)
    cell_num = size(CV, 1)
    @< Build the d-IntervalTrees @>
    @< Create the mapping @>
    mapping
end
@}
The basic idea is to "unfold" every $d$-dimensional bounding box into $d$ one-dimensional boxes.
To do so, one interval tree per dimension must be created. 
We build the $d$-trees by firstly building the intervals for each box and then the trees.
In this way we keep in memory the \texttt{boxes1D} array (which contains the intervals) for later use.
%##########################%
@D Build the d-IntervalTrees
@{IntervalsType = IntervalValue{Float64, Int64}
boxes1D = Array{IntervalsType, 2}(0, d)
for ci in 1:cell_num
    intervals = map((l,u)->IntervalsType(l,u,ci), bbox(V,CV[ci, :])...)
    boxes1D = vcat(boxes1D, intervals)
end
trees = mapslices(IntervalTree{Float64, IntervalsType}, sort(boxes1D, 1), 1)
@}
The \textit{spatial index} is returned as an array of \texttt{Int64} arrays.
The \texttt{intersect\_intervals} function returns every cell of which its bounding box collides with 
the $d$-intervals passed as argument. This function then is called for the $d$-intervals (stored in the \texttt{boxes1D} array) of every cell.
Obviously every cell collides with itself, so a set difference is performed for every cell to exclude itself from the mapping.
%###################%
@D Create the mapping
@{function intersect_intervals(intervals)
    cells = Array{Int64,1}[]
    for axis in 1:d
        vs = map(i->i.value, intersect(trees[axis], intervals[axis]))
        push!(cells, vs)
    end
    mapreduce(x->x, intersect, cells)
end

mapping = Array{Int64,1}[]
for ci in 1:cell_num
    cell_indexes = setdiff(intersect_intervals(boxes1D[ci, :]), [ci])
    push!(mapping, cell_indexes)
end
@}



%%%%%%%%%%%%%%%%%
\section{Testing}
%%%%%%%%%%%%%%%%%
@O test/jl/utilities.jl
@{using Base.Test
include("../../lib/jl/utilities.jl")

Xs = (
    [[[1 2];[3 2]],[[1,2]]],
    [[[1 3];[2 1]],[[1,2]]],
    [[[2 3];[3 1]],[[1,2]]],
    [[[1.5 1];[2.5 3]],[[1,2]]]
)

V,CV = skel_union(Xs)

@@testset "skel_union test" begin
    @@test V == [[1 2];[3 2];[1 3];[2 1];[2 3];[3 1];[1.5 1];[2.5 3]]
    @@test full(CV) == [
        [1 1 0 0 0 0 0 0]
        [0 0 1 1 0 0 0 0]
        [0 0 0 0 1 1 0 0]
        [0 0 0 0 0 0 1 1]
    ]
end

lower, upper = bbox(V, CV[2, :])
@@testset "bbox test" begin
    @@test lower == [1 1]
    @@test upper == [2 3]
end

mapping = spatial_index(V,CV)
@@testset "spatial_index test" begin
    @@test mapping == [[2,4,3], [1,4,3], [2,1,4], [2,1,3]]
end



@}
\end{document}