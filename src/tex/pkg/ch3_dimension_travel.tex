
\chapter{Dimension travel}

%%%%%%%%%%%%%%%%%%
\section{Overview}
@O lib/jl/dimension_travel.jl
@{@< Imports and aliases @>
@< Dimension travel functions @>
@}
We define some aliases to standardize data formats.
@D Imports and aliases
@{typealias Verts Array{Float64, 2}
typealias Cells SparseMatrixCSC{Int8, Int}
typealias Cell SparseVector{Int8, Int}
@}
%+++++++++++++%
\subsection{Tests}
@O test/jl/dimension_travel.jl
@{using Base.Test
include("../../lib/jl/dimension_travel.jl")

@< Tests @>
@}


%%%%%%%%%%%%%%%%%%%%%%%
\section{Normalization}
This function returns the direct and inverse transformation that
normalizes every point in \texttt{V} to mek them fit into the unitary
$d$-dimensional hyper-cube.
First of all, the function computes the bounding box of the input points.
Then it combines a translation and a scaling matrix. Lastly, it
inverts the matrix and returns both the direct and the inverse matrix.
@D Dimension travel functions
@{function normalizer(V::Verts)
    d = size(V, 2)
    upper = mapslices(x->max(x...), V, 1)
    lower = mapslices(x->min(x...), V, 1)
    diff = upper-lower

    T = eye(d+1)
    T[d+1, 1:d] = -lower

    S = eye(d+1)
    S[1:d, 1:d] = diagm(vec(map(inv, diff)))

    mat = T*S
    mat, inv(mat)
end
@}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Submanifold mapping}

This function, given a list of vertices \texttt{V} (in $\mathbb{E}^3$) and a 
\texttt{face}, returns a $4\times4$ transformation matrix that "flattens"
\texttt{face} on the $x_3=0$ plane. The matrix is made of the composition of
a translation matrix and a coordinate reference change. The translation
makes the first vertex of \texttt{face} coincident to the origin and
the coordinate reference change is computed by building a reference
system of the plane on which \texttt{face} lays.

@D Dimension travel functions
@{function submanifold_mapping(V, face)
    p1, p2, p3 = map(i->V[face.nzind[i], :], 1:3)
    u1 = p2-p1
    u2 = p3-p1
    u3 = cross(u1, u2)
    T = eye(4)
    T[4, 1:3] = -p1
    M = eye(4)
    M[1:3, 1:3] = [u1 u2 u3]
    return T*M
end
@}
%----------------%
\subsection{Tests}

@D Tests
@{V = rand(3, 3)
face = sparsevec(Int8[1 1 1])
m = submanifold_mapping(V, face)
err = 1e-10 
@@testset "submanifold_mapping test" begin
    @@test any(map((x,y)->-err<x-y<err, m*inv(m), eye(4)))
    @@test any(x->-err<x<err, ([V [1; 1; 1]]*m)[:, 3])
end
@}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Spatial index computation}

The aim of this function is to compute a \textit{spatial index} that maps
each cell to a set of cells which it may collide with.
This is achieved by profuse use of bounding boxes and interval trees. 
These last ones are implemented with the \texttt{IntervalTrees.jl} package
(\url{https://github.com/BioJulia/IntervalTrees.jl})

@D Imports and aliases
@{using IntervalTrees
@}

@D Dimension travel functions
@{function spatial_index(V::Verts, CV::Cells)
    d = size(V,2)
    cell_num = size(CV, 1)
    @< Build the d-IntervalTrees @>
    @< Create the mapping @>
    mapping
end
@}

The basic idea is to "unfold" every $d$-dimensional bounding box into $d$ one-dimensional boxes.
To do so, one interval tree per dimension must be created. 
We build the $d$-trees by firstly building the intervals for each box and then the trees.
In this way we keep in memory the \texttt{boxes1D} array (which contains the intervals) for later use.

@D Build the d-IntervalTrees
@{IntervalsType = IntervalValue{Float64, Int64}
boxes1D = Array{IntervalsType, 2}(0, d)
for ci in 1:cell_num
    intervals = map((l,u)->IntervalsType(l,u,ci), bbox(V,CV[ci, :])...)
    boxes1D = vcat(boxes1D, intervals)
end
trees = mapslices(IntervalTree{Float64, IntervalsType}, sort(boxes1D, 1), 1)
@}

The \textit{spatial index} is returned as an array of \texttt{Int64} arrays.
The \texttt{intersect\_intervals} function returns every cell of which its bounding box collides with 
the $d$-intervals passed as argument. This function then is called for the $d$-intervals (stored in the \texttt{boxes1D} array) of every cell.
Obviously every cell collides with itself, so a set difference is performed for every cell to exclude itself from the mapping.

@D Create the mapping
@{function intersect_intervals(intervals)
    cells = Array{Int64,1}[]
    for axis in 1:d
        vs = map(i->i.value, intersect(trees[axis], intervals[axis]))
        push!(cells, vs)
    end
    mapreduce(x->x, intersect, cells)
end

mapping = Array{Int64,1}[]
for ci in 1:cell_num
    cell_indexes = setdiff(intersect_intervals(boxes1D[ci, :]), [ci])
    push!(mapping, cell_indexes)
end
@}