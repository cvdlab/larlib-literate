\documentclass[10pt,oneside]{article}
\usepackage{hyperref}
\usepackage{amsmath}
\hypersetup{colorlinks = true}

\author{Alberto Paoluzzi, Francesco Furiani, Giulio Martella}
\title{Cells intersections
\footnote{This document is part of the \emph{Linear Algebraic Representation} (LAR.jl) framework.}
}

\begin{document}
\maketitle
\newpage

%%%%%%%%%%%%%%%%%%
\section{Overview}
%%%%%%%%%%%%%%%%%%
The \texttt{intersect.jl} script file contains a set of functions to perform intersection
operations on multiple cellular complexes of dimension $d$.
@O lib/jl/intersect.jl
@{@< Imports and aliases @>
@< Skeletal union @>
@< Bounding box computation @>
@< Compute spatial index @>
@< Segment intersection @>
@< Segment fragmentation @>
@< Planar Arrangement @>
@< Vertices merge @>
@}
We define some type aliases to define the default vay to store data.
Please note that we use the Julia's default CSC sparse matrices implementation
to store cells.
%####################%
@D Imports and aliases
@{typealias Verts Array{Float64,2}
typealias Cells SparseMatrixCSC{Int8,Int64}
typealias Cell SparseVector{Int8,Int64}
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Combinatorial union of $(d-1)$-cells}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This function converts cellular complexes into a bidimensional array \texttt{V} of 
vertices and a CSC sparse matrix \texttt{CV} of cells. The input must be an array of complexes
in which the vertices are expressed as a bidimensional array and the cells as a BRC
sparse matrix.
%###############%
@D Skeletal union
@{function skel_union(Xs)
    d = size(Xs[1][1], 2)
    @< Compute V and the BRC sparse matrix @>
    @< Build CV, the CSC sparse matrix @>
    V,CV
end
@}
%####################################%
@D Compute V and the BRC sparse matrix
@{V = Verts(0,d)
BRC = Array{Array{Int64, 1}, 1}()
for h = 1:size(Xs,1)
    BRC = vcat(BRC, Xs[h][2] + size(V,1))
    V = vcat(V, Xs[h][1])
end
@}
%################################%
@D Build CV, the CSC sparse matrix
@{n = length(BRC)
m = size(V,1)
CV = spzeros(Int8, n,m)
for c in 1:n
    cell = BRC[c]
    for i in 1:length(cell)
        CV[c, cell[i]] = 1
    end
end
@}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cell bounding boxes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The function to compute the bounding box of a cell
is pretty straightforward.
%#########################%
@D Bounding box computation
@{function bbox(V::Verts, cell::Cell)
    d = size(V,2)
    VS = Verts(0,d)
    for i in cell.nzind
        VS = vcat(VS, reshape(V[i, :], 1, 2))
    end
    
    lower = mapslices(x->min(x...), VS, 1)
    upper = mapslices(x->max(x...), VS, 1)
    
    lower, upper
end
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Spatial index computation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The aim of this function is to compute a \textit{spatial index} that maps
each cell to a set of cells which it may collide with.
This is achieved by profuse use of bounding boxes and interval trees. 
These last ones are implemented with the \texttt{IntervalTrees.jl} package
(\url{https://github.com/BioJulia/IntervalTrees.jl})
%####################%
@D Imports and aliases
@{using IntervalTrees
@}
%######################%
@D Compute spatial index
@{function spatial_index(V::Verts, CV::Cells)
    d = size(V,2)
    cell_num = size(CV, 1)
    @< Build the d-IntervalTrees @>
    @< Create the mapping @>
    mapping
end
@}
The basic idea is to "unfold" every $d$-dimensional bounding box into $d$ one-dimensional boxes.
To do so, one interval tree per dimension must be created. 
We build the $d$-trees by firstly building the intervals for each box and then the trees.
In this way we keep in memory the \texttt{boxes1D} array (which contains the intervals) for later use.
%##########################%
@D Build the d-IntervalTrees
@{IntervalsType = IntervalValue{Float64, Int64}
boxes1D = Array{IntervalsType, 2}(0, d)
for ci in 1:cell_num
    intervals = map((l,u)->IntervalsType(l,u,ci), bbox(V,CV[ci, :])...)
    boxes1D = vcat(boxes1D, intervals)
end
trees = mapslices(IntervalTree{Float64, IntervalsType}, sort(boxes1D, 1), 1)
@}
The \textit{spatial index} is returned as an array of \texttt{Int64} arrays.
The \texttt{intersect\_intervals} function returns every cell of which its bounding box collides with 
the $d$-intervals passed as argument. This function then is called for the $d$-intervals (stored in the \texttt{boxes1D} array) of every cell.
Obviously every cell collides with itself, so a set difference is performed for every cell to exclude itself from the mapping.
%###################%
@D Create the mapping
@{function intersect_intervals(intervals)
    cells = Array{Int64,1}[]
    for axis in 1:d
        vs = map(i->i.value, intersect(trees[axis], intervals[axis]))
        push!(cells, vs)
    end
    mapreduce(x->x, intersect, cells)
end

mapping = Array{Int64,1}[]
for ci in 1:cell_num
    cell_indexes = setdiff(intersect_intervals(boxes1D[ci, :]), [ci])
    push!(mapping, cell_indexes)
end
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Segment intersection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{seg_intersection}
Here is presented a basic segment intersection function.
It is based on the method presented here: \url{http://paulbourke.net/geometry/pointlineplane/}.
The function works of 1-cells in $d=2$.
The function can return 0, 1 or 2 intersection points. Two intersection points are
returned only if both the cells are colinear and the second cell is contained in the first one.
Each intersection is stored in a \texttt{Tuple\{Float64,Verts\}} where 
the \texttt{Float64} is the parameter of the intersection and the \texttt{Verts} 
is the approximate point of intersection.
%#####################%
@D Segment intersection
@{function seg_intersection(V::Verts, cell1::Cell, cell2::Cell)
    x1, y1, x2, y2 = vcat(map(c->V[c, :], cell1.nzind)...)
    x3, y3, x4, y4 = vcat(map(c->V[c, :], cell2.nzind)...)
    ret = Array{Tuple{Float64, Verts}, 1}()
    denom = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1)
    a = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / denom
    b = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / denom
    
    if 0 < a < 1 && 0 < b < 1
        p = [(x1 + a*(x2-x1))  (y1 + a*(y2-y1))]
        push!(ret, (a, p))
    elseif isnan(a) && isnan(b) 
        o = [x1 y1] 
        v = [x2 y2] - o
        alpha = 1/dot(v,v')
        ps = [x3 y3; x4 y4]
        for i in 1:2
            a = alpha*dot(v',(ps[i]-o))
            if 0 < a < 1
                push!(ret, (a, ps[i:i, :]))
            end
        end
    end
    return ret
end
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Segment fragmentation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{seg_fragmentation}
This function returns the new vertices and cells created by the intersection of 
the \texttt{to\_inters} edge with the \texttt{intersectable} edges.
\texttt{alphas} and \texttt{vertsnum} are variables used through all the function.
%######################%
@D Segment fragmentation
@{function seg_fragmentation(
    V::Verts, EV::Cells, 
    to_inters::Cell, intersectable::Cells
)
    alphas = Dict{Float64, Int64}()
    vertsnum = size(V, 1)

    @< Compute the intersections @>
    @< Add new cells to EV @>
    
    retV, retEV
end
@}
For each cell in \texttt{intersectable} are computed the intersections with \texttt{to\_inters} via 
the \hyperref[seg_intersection]{\texttt{seg\_intersection}} function. The intersection points are
stored in \texttt{V} and \texttt{retV} then the parameters are coupled to the index of the newly 
computed vertices into the \texttt{alphas} dictionary.
%##########################%
@D Compute the intersections
@{retV = Verts(0, size(V, 2))
for cell in 1:size(intersectable, 1)
    inters = seg_intersection(V, to_inters, intersectable[cell, :])
    while !isempty(inters)
        alpha, point = pop!(inters)
        V = vcat(V, point)
        retV = vcat(retV, point)
        alphas[alpha] = size(V,1)
    end
end
@}
We sort and iterate over the key set of \texttt{alphas}
to fill a newly generated \texttt{retEV} matrix. As previously stated, \texttt{alphas} maps 
the parameters of the intersections to the indices of the new vertices, so the sorting of the keys 
is important to create coherent and consecutive cells.
%####################%
@D Add new cells to EV
@{alphaskeys = sort(collect(keys(alphas)))
alphasnum = length(alphaskeys)

nvertsnum = size(V, 1)
retEV = spzeros(Int8, alphasnum+1, nvertsnum)
for a in 1:alphasnum
    if a == 1
        retEV[1, to_inters.nzind[1]] = 1
        retEV[1, alphas[alphaskeys[a]]] = 1
    end
    if a == alphasnum
        retEV[alphasnum+1, alphas[alphaskeys[a]]] = 1
        retEV[alphasnum+1, to_inters.nzind[2]] = 1
    else
        retEV[a+1, alphas[alphaskeys[a]]] = 1
        retEV[a+1, alphas[alphaskeys[a+1]]] = 1
    end
end
@}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Planar Arrangement}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Given \texttt{sigma} 1-skeleton flattened on the $z=0$ plane and the intersections with $z=0$ of the 2-cells
that can intersect \texttt{sigma}, the function returns \texttt{sigma} fully fragmented.
%###################%
@D Planar Arrangement
@{function planar_arrangement(
    Vsigma::Verts, EVsigma::Cells, 
    Vinters::Verts, EVinters::Cells
)
    @< Merge data matrices @>
    @< Build return matrices @>
    @< Fragment cells @>
    @< Delete marked cells @>

    retV, retEV
end
@}
We firstly need to merge the input data. We concatenate the vertices lists in \texttt{V} and 
we build a big \texttt{EV} matrix to store both \texttt{EVsigma} and \texttt{EVinters}:
\begin{equation}
    \texttt{EV} = 
    \begin{bmatrix}
        \begin{array}{c|c}
            \texttt{EVsigma} & 0 \\ 
            \hline
            0 & \texttt{EVinters}
        \end{array}
    \end{bmatrix}
\end{equation}
%####################%
@D Merge data matrices
@{EVs_size = size(EVsigma)
EVi_size = size(EVinters)
cellsnum = EVs_size[1] + EVi_size[1]
V = vcat(Vsigma, Vinters)
EV = spzeros(Int8, cellsnum, EVs_size[2] + EVi_size[2])
EV[1:EVs_size[1], 1:EVs_size[2]] = EVsigma
EV[EVs_size[1]+1:end, EVs_size[2]+1:end] = EVinters
@}
Now we build the \texttt{retEV} and \texttt{retV} matrices that will store 
the data of the fragmentation. \texttt{retEV} initially contains only the cells 
of the 1-skeleton of \texttt{sigma} because the only original 1-cells that the 
result should contain are the ones from \texttt{sigma} which have no intersections 
with other cells.
%######################%
@D Build return matrices
@{overtsnum = size(V, 1)  # original vertices number
ocellsnum = EVs_size[1]  # original cells number
retEV = hcat(EVsigma[:, :], spzeros(Int8, ocellsnum, overtsnum-EVs_size[2]))

retV = V[:, :]
@}
For each 1-cell we compute its fragmentation with the \hyperref[seg_fragmentation]{\texttt{seg\_fragmentation}} 
function and we push the data into the \texttt{retEV}(adding columns and rows) and \texttt{retV} matrices.
While we iterate the cells we store into \texttt{todelete} the cells of \texttt{sigma} which 
intersect with cells outside \texttt{sigma}.
%###############%
@D Fragment cells
@{todelete = Array{Int64, 1}()
for i in 1:cellsnum

    cells = vcat(EV[1:i-1, :], EV[i+1:end, :])
    nV, nEV = seg_fragmentation(V, EV, EV[i,:], cells)

    if size(nV,1) != 0
        ncellsnum = size(nEV, 1) # new cells number
        nvertsnum = size(nEV-overtsnum, 2) # new vertices number

        origvs_EV = nEV[:, 1:overtsnum]
        origvs_EV = hcat(
            origvs_EV,
            spzeros(Int8, ncellsnum, size(retV,1)-overtsnum)
        )
        
        retEV = vcat(retEV, origvs_EV)

        nvs_EV = nEV[:, overtsnum+1:end]
        nvs_EV = vcat(
            spzeros(Int8, size(retEV,1)-ncellsnum, size(nvs_EV, 2)),
            nvs_EV
        )

        retEV = hcat(retEV, nvs_EV)
        
        retV = vcat(retV, nV)

        if i <= ocellsnum
            push!(todelete, i)
        end
    end
end
@}
We finally delete the cells marked to be deleted into the \texttt{todelete} stack.
%####################%
@D Delete marked cells
@{while !isempty(todelete) 
    i = pop!(todelete)
    retEV = vcat(retEV[1:i-1, :], retEV[i+1:end, :])
end
@}


%%%%%%%%%%%%%%%%%%%%%%%%
\section{Vertices merge}
%%%%%%%%%%%%%%%%%%%%%%%%
We import the \texttt{NearestNeighbors.jl} package that provides a good implementation of
the \texttt{KDTree} data structure. 
(\url{https://github.com/KristofferC/NearestNeighbors.jl}).
%####################%
@D Imports and aliases
@{using NearestNeighbors
@}
%###############%
@D Vertices merge
@{function merge_vertices(V::Verts, EV::Cells, e=10^-10.)
    kdtree = KDTree(V')
    tocheck = collect(size(V,1):-1:1)
    todelete = Array{Int64, 1}()
    @< Iterate over tocheck @>
    @< Delete vertices in todelete @>
    V,EV
end
@}
We create two stacks: \texttt{tocheck} which contains the indices of the vertices
to check and \texttt{todelete} that stores the indices of the vertices to delete later.
Into \texttt{tocheck} we put all the vertices of the complex in reverse order, because
this way we can pop from the stack the indices in order. So, until \texttt{tocheck} is not empty,
we pop a vertex \texttt{vi} from the stack and for each coincident vertex \texttt{vj}, we put it 
into the \texttt{todelete} stack and we sum the columns of \texttt{EV} that points to \texttt{vi} and \texttt{vj}
%#####################%
@D Iterate over tocheck 
@{while !isempty(tocheck)
    vi = pop!(tocheck)
    if !(vi in todelete)
        nearvs = inrange(kdtree, V[vi, :], e)
        for vj in nearvs
            if vj != vi
                push!(todelete, vj)
                EV[:,vi] = EV[:, vi] + EV[:, vj]
            end
        end
    end
end
@}
At last we simply delete the vertices from the \texttt{V} and their 
corresponding columns of \texttt{EV}.
%####################%
@D Delete vertices in todelete
@{while !isempty(todelete)
    vi = pop!(todelete)
    EV = hcat(EV[:, 1:vi-1], EV[:, vi+1:end])
    V = vcat(V[1:vi-1, :], V[vi+1:end, :])
end
@}







%%%%%%%%%%%%%%%%%
\section{Testing}
%%%%%%%%%%%%%%%%%
@O test/jl/intersect.jl
@{using Base.Test
include("../../lib/jl/intersect.jl")

Xs = (
    [[[1 2];[3 2]],[[1,2]]],
    [[[1 3];[2 1]],[[1,2]]],
    [[[2 3];[3 1]],[[1,2]]],
    [[[1.5 1];[2.5 3]],[[1,2]]]
)

V,CV = skel_union(Xs)

@@testset "skel_union test" begin
    @@test V == [[1 2];[3 2];[1 3];[2 1];[2 3];[3 1];[1.5 1];[2.5 3]]
    @@test full(CV) == [
        [1 1 0 0 0 0 0 0]
        [0 0 1 1 0 0 0 0]
        [0 0 0 0 1 1 0 0]
        [0 0 0 0 0 0 1 1]
    ]
end

lower, upper = bbox(V, CV[2, :])
@@testset "bbox test" begin
    @@test lower == [1 1]
    @@test upper == [2 3]
end

mapping = spatial_index(V,CV)
@@testset "spatial_index test" begin
    @@test mapping == [[2,4,3], [1,4,3], [2,1,4], [2,1,3]]
end

V2 = [0 0; 3 3; 1 1; 2 2; 0 3; 3 0.]
CV2 = sparse(Array{Int8, 2}([
    [1 1 0 0 0 0]
    [0 0 1 1 0 0]
    [1 0 1 0 0 0]
    [0 1 0 1 0 0]
    [0 0 0 0 1 1]
]))
inters1 = seg_intersection(V2, CV2[1, :], CV2[2, :])
inters2 = seg_intersection(V2, CV2[1, :], CV2[5, :])
inters3 = seg_intersection(V2, CV2[3, :], CV2[4, :])
@@testset "seg_intersection test" begin
    @@test inters1 == [(1/3, [1. 1.]),(2/3, [2. 2.])]
    @@test inters2 == [(.5, [1.5 1.5])]
    @@test inters3 == []
end

V,CV = seg_fragmentation(V, CV, CV[1, :], CV[2:end, :])
V2, CV2 = seg_fragmentation(V2, CV2, CV2[1, :], CV2[2:2, :])
@@testset "seg_fragmentation test" begin
    @@test V == [1.5 2.0; 2.5 2.0; 2.0 2.0]
    @@test full(CV) == [
        [1 0 0 0 0 0 0 0 1 0 0]
        [0 0 0 0 0 0 0 0 1 0 1]
        [0 0 0 0 0 0 0 0 0 1 1]
        [0 1 0 0 0 0 0 0 0 1 0]
    ]
    @@test V2 == [2. 2.; 1. 1.]
    @@test full(CV2) == [
        [1 0 0 0 0 0 0 1]
        [0 0 0 0 0 0 1 1]
        [0 1 0 0 0 0 1 0]
    ] 
end

Xs = [[[[0 0];[1 1];[0 1];[1 0];[1.5 1.5];[1.5 1.5]],[[1,5],[2,5],[3,6],[4,6]]]]
V, EV = skel_union(Xs)
V, EV = merge_vertices(V,EV)
@@testset "merge_vertices test" begin
    @@test V == [[0 0];[1 1];[0 1];[1 0];[1.5 1.5]]
    @@test full(EV) == [
        [1 0 0 0 1]
        [0 1 0 0 1]
        [0 0 1 0 1]
        [0 0 0 1 1]
    ]
end

Vs = [0. 0; 5 0; 2.5 4]
EVs = sparse([1,1,2,2,3,3], [1,3,1,2,2,3], Int8(1))
Vi = [-1. 2; 6 2]
EVi = sparse([1,1], [1,2], Int8(1))
rV, rEV = planar_arrangement(Vs, EVs, Vi, EVi)
@@testset "planar_arrangement test" begin
    @@test rV == [0 0; 5 0; 2.5 4; -1 2; 6 2; 1.25 2; 3.75 2; 1.25 2; 3.75 2]
    @@test full(rEV) == [
        [1 1 0 0 0 0 0 0 0]
        [1 0 0 0 0 1 0 0 0]
        [0 0 1 0 0 1 0 0 0]
        [0 1 0 0 0 0 1 0 0]
        [0 0 1 0 0 0 1 0 0]
        [0 0 0 1 0 0 0 1 0]
        [0 0 0 0 0 0 0 1 1]
        [0 0 0 0 1 0 0 0 1]
    ]
end
@}
\end{document}