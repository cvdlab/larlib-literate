\documentclass[10pt,oneside]{article}
\usepackage{hyperref}
\hypersetup{colorlinks = true}

\author{Alberto Paoluzzi, Francesco Furiani, Giulio Martella}
\title{Cells intersections
\footnote{This document is part of the \emph{Linear Algebraic Representation} (LAR.jl) framework.}
}

\begin{document}
\maketitle
\newpage

%%%%%%%%%%%%%%%%%%
\section{Overview}
The \texttt{intersect.jl} script file contains a set of functions to perform intersection
operations on multiple cellular complexes of dimension $d$.
@O lib/jl/intersect.jl
@{@< Imports and aliases @>
@< Skeletal union @>
@< Bounding box computation @>
@< Compute spatial index @>
@< Segment intersection @>
@< Segment fragmentation @>
@}
We define some type aliases to define the default vay to store data.
Please note that we use the Julia's default CSC sparse matrices implementation
to store cells.
@D Imports and aliases
@{typealias Verts Array{Float64,2}
typealias Cells SparseMatrixCSC{Int8,Int64}
typealias Cell SparseVector{Int8,Int64}
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Combinatorial union of $(d-1)$-cells}
This function converts cellular complexes into a bidimensional array \texttt{V} of 
vertices and a CSC sparse matrix \texttt{CV} of cells. The input must be an array of complexes
in which the vertices are expressed as a bidimensional array and the cells as a BRC
sparse matrix.
@D Skeletal union
@{function skel_union(Xs)
    d = size(Xs[1][1], 2)
    @< Compute V and the BRC sparse matrix @>
    @< Build CV, the CSC sparse matrix @>
    V,CV
end
@}
@D Compute V and the BRC sparse matrix
@{V = Verts(0,d)
BRC = Array{Array{Int64, 1}, 1}()
for h = 1:size(Xs,1)
    BRC = vcat(BRC, Xs[h][2] + size(V,1))
    V = vcat(V, Xs[h][1])
end
@}
@D Build CV, the CSC sparse matrix
@{n = length(BRC)
m = size(V,1)
CV = spzeros(Int8, n,m)
for c in 1:n
    cell = BRC[c]
    for i in 1:length(cell)
        CV[c, cell[i]] = 1
    end
end
@}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cell bounding boxes}
The function to compute the bounding box of a cell
is pretty straightforward.
@D Bounding box computation
@{function bbox(V::Verts, cell::Cell)
    d = size(V,2)
    VS = Verts(0,d)
    for i in cell.nzind
        VS = vcat(VS, reshape(V[i, :], 1, 2))
    end
    
    lower = mapslices(x->min(x...), VS, 1)
    upper = mapslices(x->max(x...), VS, 1)
    
    lower, upper
end
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Spatial index computation}
The aim of this function is to compute a \textit{spatial index} that maps
each cell to a set of cells which it may collide with.
This is achieved by profuse use of bounding boxes and interval trees. 
These last ones are implemented with the IntervalTrees library
(\url{https://github.com/BioJulia/IntervalTrees.jl})
@D Imports and aliases
@{using IntervalTrees
@}

@D Compute spatial index
@{function spatial_index(V::Verts, CV::Cells)
    d = size(V,2)
    cell_num = size(CV, 1)
    @< Build the d-IntervalTrees @>
    @< Create the mapping @>
    mapping
end
@}
The basic idea is to "unfold" every $d$-dimensional bounding box into $d$ one-dimensional boxes.
To do so, one interval tree per dimension must be created. 
We build the $d$-trees by firstly building the intervals for each box and then the trees.
In this way we keep in memory the \texttt{boxes1D} array (which contains the intervals) for later use.
@D Build the d-IntervalTrees
@{IntervalsType = IntervalValue{Float64, Int64}
boxes1D = Array{IntervalsType, 2}(0, d)
for ci in 1:cell_num
    intervals = map((l,u)->IntervalsType(l,u,ci), bbox(V,CV[ci, :])...)
    boxes1D = vcat(boxes1D, intervals)
end
trees = mapslices(IntervalTree{Float64, IntervalsType}, sort(boxes1D, 1), 1)
@}
The \textit{spatial index} is returned as an array of \texttt{Int64} arrays.
The \texttt{intersect\_intervals} function returns every cell of which its bounding box collides with 
the $d$-intervals passed as argument. This function then is called for the $d$-intervals (stored in the \texttt{boxes1D} array) of every cell.
Obviously every cell collides with itself, so a set difference is performed for every cell to exclude itself from the mapping.
@D Create the mapping
@{function intersect_intervals(intervals)
    cells = Array{Int64,1}[]
    for axis in 1:d
        vs = map(i->i.value, intersect(trees[axis], intervals[axis]))
        push!(cells, vs)
    end
    mapreduce(x->x, intersect, cells)
end

mapping = Array{Int64,1}[]
for ci in 1:cell_num
    cell_indexes = setdiff(intersect_intervals(boxes1D[ci, :]), [ci])
    push!(mapping, cell_indexes)
end
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Segment intersection}
\label{seg_intersection}
Here is presented a basic segment intersection function.
It is based on the method presented here: \url{http://paulbourke.net/geometry/pointlineplane/}.
The function works only if $d=2$ and the cells are edges.
If there is an intersection, it returns a \texttt{Tuple\{Float64,Verts\}} where 
the \texttt{Float64} is the parameter of the intersection and the \texttt{Verts} 
is the approximate point of intersection. \\
\texttt{false} is returned in case of no intersection.
@D Segment intersection
@{function seg_intersection(V::Verts, cell1::Cell, cell2::Cell)
    x1, y1, x2, y2 = vcat(map(c->V[c, :], cell1.nzind)...)
    x3, y3, x4, y4 = vcat(map(c->V[c, :], cell2.nzind)...)
    
    denom = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1)
    a = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / denom
    b = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / denom

    if 0 <= a <= 1 && 0 <= b <= 1
        p = [(x1 + a*(x2-x1))  (y1 + a*(y2-y1))]
        return a, p
    end

    return false
end
@}

\section{Segment fragmentation}
This function computes the cellular complex after performing the intersection of the \texttt{sigma} edge 
with the \texttt{sigma\_int} edges.
\texttt{alphas}, \texttt{vertsnum} and \texttt{cellsnum} are variables used through all the function.
@D Segment fragmentation
@{function seg_fragmentation(V::Verts, EV::Cells, sigma::Cell, sigma_int::Cells)
    alphas = Dict{Float64, Int64}()
    vertsnum = size(V, 1)
    cellsnum = size(EV, 1)
    @< Compute the intersections @>
    @< Add new cells to EV @>
    @< Delete sigma from EV @>
    V, EV
end
@}
For each cell in \texttt{sigma\_int} are computed the intersections with \texttt{sigma} via 
the \hyperref[seg_intersection]{\texttt{seg\_intersection}} function. The intersection point is
stored in \texttt{V} and the parameter is coupled to the index of the newly computed vertex into 
the \texttt{alphas} dictionary.
@D Compute the intersections
@{for cell in 1:size(sigma_int, 1)
    inters = seg_intersection(V, sigma, sigma_int[cell, :])
    if inters != false
        alpha, point = inters
        V = vcat(V, point)
        alphas[alpha] = size(V,1)
    end
end
@}
The \texttt{EV} matrix must be widened to fit the new vertices and the cells derived from 
the fragmentation of \texttt{sigma}. Then we sort and iterate over the key set of \texttt{alphas}
to fill the empty cells of \texttt{EV} just generated. As previously stated, \texttt{alphas} maps 
the parameters of the intersections to the indices of the new vertices, so the sorting of the keys 
is important to create coherent and consecutive cells.
@D Add new cells to EV
@{nvertsnum = size(V, 1)
EV = hcat(EV, spzeros(Int8, cellsnum, nvertsnum-vertsnum))
EV = vcat(EV, spzeros(Int8, alphasnum+1, nvertsnum))

alphaskeys = sort(collect(keys(alphas)))
alphasnum = length(alphaskeys)
for a in 1:alphasnum
    if a == 1
        EV[cellsnum+1, sigma.nzind[1]] = 1
        EV[cellsnum+1, alphas[alphaskeys[a]]] = 1
    end
    if a == alphasnum
        EV[cellsnum+alphasnum+1, alphas[alphaskeys[a]]] = 1
        EV[cellsnum+alphasnum+1, sigma.nzind[2]] = 1
    else
        EV[cellsnum+a+1, alphas[alphaskeys[a]]] = 1
        EV[cellsnum+a+1, alphas[alphaskeys[a+1]]] = 1
    end
end
@}
At last we delete \texttt{sigma} from EV. More than one repetition of sigma can 
be stored into EV. Here is safe to delete only the first occurrence because the 
others will be deleted on the other calls of this function.
@D Delete sigma from EV
@{todel = intersect(map(col->EV[:, col].nzind, sigma.nzind)...)[1]
EV = vcat(EV[1:todel-1, :], EV[todel+1:end, :])
@}

%%%%%%%%%%%%%%%%%
\section{Testing}
@O test/jl/intersect.jl
@{using Base.Test
include("../../lib/jl/intersect.jl")

Xs = (
    [[[1 2];[3 2]],[[1,2]]],
    [[[1 3];[2 1]],[[1,2]]],
    [[[2 3];[3 1]],[[1,2]]],
    [[[1.5 1];[2.5 3]],[[1,2]]]
)

@< Skeletal union tests @>
@< Bounding box tests @>
@< Spatial index test @>
@< Segment intersection test @>
@< Segment fragmentation test @>
@}
@D Skeletal union tests
@{V,CV = skel_union(Xs)
@@testset "skel_union tests" begin
    @@test V == [[1 2];[3 2];[1 3];[2 1];[2 3];[3 1];[1.5 1];[2.5 3]]
    @@test full(CV) == [
        [1 1 0 0 0 0 0 0]
        [0 0 1 1 0 0 0 0]
        [0 0 0 0 1 1 0 0]
        [0 0 0 0 0 0 1 1]
    ]
end
@}
@D Bounding box tests
@{lower, upper = bbox(V, CV[2, :])
@@testset "bbox tests" begin
    @@test lower == [1 1]
    @@test upper == [2 3]
end
@}
@D Spatial index test
@{mapping = spatial_index(V,CV)
@@testset "spatial_index test" begin
    @@test mapping == [[2,4,3], [1,4,3], [2,1,4], [2,1,3]]
end
@}
@D Segment intersection test
@{intersection = seg_intersection(V,CV[1, :],CV[2, :])
@@testset "seg_intersection test" begin
    @@test intersection == (.25, [1.5 2.0])
end
@}
@D Segment fragmentation test
@{V,CV = seg_fragmentation(V, CV, CV[1, :], CV[2:end, :])
@@testset "seg_fragmentation test" begin
    @@test V == [[1 2];[3 2];[1 3];[2 1];[2 3];[3 1];[1.5 1];[2.5 3];[1.5 2];[2.5 2];[2 2]]
    @@test full(CV) == [
        [0 0 1 1 0 0 0 0 0 0 0]
        [0 0 0 0 1 1 0 0 0 0 0]
        [0 0 0 0 0 0 1 1 0 0 0]
        [1 0 0 0 0 0 0 0 1 0 0]
        [0 0 0 0 0 0 0 0 1 0 1]
        [0 0 0 0 0 0 0 0 0 1 1]
        [0 1 0 0 0 0 0 0 0 1 0]
    ]
end
@}
\end{document}