\documentclass[10pt,oneside]{article}
\usepackage{hyperref}

\author{Alberto Paoluzzi, Francesco Furiani, Giulio Martella}
\title{Cells intersections
\footnote{This document is part of the \emph{Linear Algebraic Representation} (LAR.jl) framework.}
}

\begin{document}
\maketitle
\newpage

%%%%%%%%%%%%%%%%%%
\section{Overview}
The \texttt{intersect.jl} script file contains a set of functions to perform intersection
operations on multiple cellular complexes of dimension $d$.
@O lib/jl/intersect.jl
@{@< Imports and aliases @>
@< Skeletal union @>
@< Bounding box computation @>
@< Compute spatial index @>
@< Segment intersection @>
@< Segment fragmentation @>
@}
We use a type alias to make the bi-dimensional \texttt{Float64} array 
the default way to store vertices:
@D Imports and aliases
@{typealias Verts Array{Float64,2}
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Combinatorial union of $(d-1)$-cells}
If the input is more than one cellular complex, there is the need to combine 
the skeletons of every complex in input. A way to perform this union is to append
the vertices and the cells of every complex into two lists while in the meantime 
renumber the cell indexes using the length of the vertices list during each step.
@D Skeletal union
@{function skel_union(Xs)
    d = size(Xs[1][1], 2)
    V,CV = Verts(0,d), Array{Int64,1}[]
    for h = 1:size(Xs,1)
        CV = vcat(CV, Xs[h][2] + size(V,1))
        V = vcat(V, Xs[h][1])
    end
    V,CV
end
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cell bounding boxes}
The function to compute the bounding box of a cell
is pretty straightforward.
@D Bounding box computation
@{function bbox(V, cell)
    d = size(V,2)
    @< Find cell vertices values @>
    @< Compute lower and upper points @>
    lower, upper
end
@}
@D Find cell vertices values
@{VS = Verts(0,d)
for i = 1:size(cell,1)
    VS = vcat(VS, reshape(V[cell[i], :], 1, 2))
end
@}
@D Compute lower and upper points
@{lower = mapslices(x->min(x...), VS, 1)
upper = mapslices(x->max(x...), VS, 1)
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Spatial index computation}
The aim of this function is to compute a \textit{spatial index} that maps
each cell to a set of cells which it may collide with.
This is achieved by profuse use of bounding boxes and interval trees. 
These last ones are implemented with the IntervalTrees library
(\url{https://github.com/BioJulia/IntervalTrees.jl})
@D Imports and aliases
@{using IntervalTrees
@}

@D Compute spatial index
@{function spatial_index(V, CV)
    d = size(V,2)
    cell_num = length(CV)
    @< Build the d-IntervalTrees @>
    @< Create the mapping @>
    mapping
end
@}
The basic idea is to "unfold" every $d$-dimensional bounding box into $d$ one-dimensional boxes.
To do so, one interval tree per dimension must be created. 
We build the $d$-trees by firstly building the intervals for each box and then the trees.
In this way we keep in memory the \texttt{boxes1D} array (which contains the intervals) for later use.
@D Build the d-IntervalTrees
@{IntervalsType = IntervalValue{Float64, Int64}
boxes1D = Array{IntervalsType, 2}(0, d)
for ci in 1:cell_num
    intervals = map((l,u)->IntervalsType(l,u,ci), bbox(V,CV[ci])...)
    boxes1D = vcat(boxes1D, intervals)
end
trees = mapslices(IntervalTree{Float64, IntervalsType}, sort(boxes1D, 1), 1)
@}
The \textit{spatial index} is returned as an array of \texttt{Int64} arrays.
The \texttt{intersect\_intervals} function returns every cell of which its bounding box collides with 
the $d$-intervals passed as argument. This function then is called for the $d$-intervals (stored in the \texttt{boxes1D} array) of every cell.
Obviously every cell collides with itself, so a set difference is performed for every cell to exclude itself from the mapping.
@D Create the mapping
@{function intersect_intervals(intervals)
    cells = Array{Int64,1}[]
    for axis in 1:d
        vs = map(i->i.value, intersect(trees[axis], intervals[axis]))
        push!(cells, vs)
    end
    mapreduce(x->x, intersect, cells)
end

mapping = Array{Int64,1}[]
for ci in 1:cell_num
    cell_indexes = setdiff(intersect_intervals(boxes1D[ci, :]), [ci])
    push!(mapping, cell_indexes)
end
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Segment intersection}
@D Segment intersection
@{function seg_intersection(V, CV, cell1, cell2)
    x1,x2,y1,y2 = V[CV[cell1], :]
    x3,x4,y3,y4 = V[CV[cell2], :]

    denom = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1)
    a = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / denom
    b = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / denom

    if 0 <= a <= 1 && 0 <= b <= 1
        p = [(x1 + a*(x2-x1))  (y1 + a*(y2-y1))]
        return a, p
    end

    return false
end
@}

\section{Segment fragmentation}
@D Segment fragmentation
@{function seg_fragmentation(V, CV)
    DictType = Dict{Int64, Tuple{Float64, Verts}}
    cell_num = length(CV)

    sindex = spatial_index(V, CV)
    frags = Array{DictType, 1}(cell_num)

    for ci in 1:cell_num
        assoc = DictType()
        for inter_c in sindex[ci]
            intersection = seg_intersection(V,CV,ci,inter_c)
            if intersection != false
                assoc[ci] = intersection
            end
        end
        frags[ci] = assoc
    end
    frags
end
@}

%%%%%%%%%%%%%%%%%
\section{Testing}
@O test/jl/intersect.jl
@{using Base.Test
include("../src/intersect.jl")

Xs = (
    [[[0 0];[2 0];[2 2];[0 2]],[[1,2],[3,4]]],
    [[[1 5];[3 1];[3 3];[1 3]],[[1,2],[3,4]]]
)

@< Skeletal union tests @>
@< Bounding box tests @>
@< Spatial index test @>
@< Segment intersection test @>
@< Segment fragmentation test @>
@}
@D Skeletal union tests
@{V,CV = skel_union(Xs)
@@testset "skel_union tests" begin
    @@test V == [[0 0];[2 0];[2 2];[0 2];[1 5];[3 1];[3 3];[1 3]]
    @@test CV == [[1,2],[3,4],[5,6],[7,8]]
end
@}
@D Bounding box tests
@{lower, upper = bbox(V, CV[3])
@@testset "bbox tests" begin
    @@test lower == [1 1]
    @@test upper == [3 5]
end
@}
@D Spatial index test
@{mapping = spatial_index(V,CV)
@@testset "spatial_index test" begin
    @@test mapping == [[2,3], [1,3], [2,1]]
end
@}
@D Segment intersection test
@{intersection = seg_intersection(V,CV,1,2)
@@testset "seg_intersection test" begin
    @@test intersection == (0.5, [1.5 2.0])
end
@}
@D Segment fragmentation test
@{frags = seg_fragmentation(V, CV)
T = Dict{Int64,Tuple{Float64,Array{Float64,2}}}
@@testset "seg_fragmentation test" begin
    @@test frags == [T(1=>(0.5,[1.5 2.0])); T(2=>(1/3,[1.5 2.0])); T()]
end
@}
\end{document}