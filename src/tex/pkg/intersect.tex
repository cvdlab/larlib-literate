\documentclass[10pt,oneside]{article}
\usepackage{hyperref}
\hypersetup{colorlinks = true}

\author{Alberto Paoluzzi, Francesco Furiani, Giulio Martella}
\title{Cells intersections
\footnote{This document is part of the \emph{Linear Algebraic Representation} (LAR.jl) framework.}
}

\begin{document}
\maketitle
\newpage

%%%%%%%%%%%%%%%%%%
\section{Overview}
The \texttt{intersect.jl} script file contains a set of functions to perform intersection
operations on multiple cellular complexes of dimension $d$.
@O lib/jl/intersect.jl
@{@< Imports and aliases @>
@< Skeletal union @>
@< Bounding box computation @>
@< Compute spatial index @>
@< Segment intersection @>
@< Segment fragmentation @>
@}
We define some type aliases to define the default vay to store data:
@D Imports and aliases
@{typealias Verts Array{Float64,2}
typealias Cells Array{Array{Int64,1},1}
typealias Cell Array{Int64,1}
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Combinatorial union of $(d-1)$-cells}
If the input is more than one cellular complex, there is the need to combine 
the skeletons of every complex in input. A way to perform this union is to append
the vertices and the cells of every complex into two lists while in the meantime 
renumber the cell indexes using the length of the vertices list during each step.
@D Skeletal union
@{function skel_union(Xs)
    d = size(Xs[1][1], 2)
    V,CV = Verts(0,d), Cells()
    for h = 1:size(Xs,1)
        CV = vcat(CV, Xs[h][2] + size(V,1))
        V = vcat(V, Xs[h][1])
    end
    V,CV
end
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cell bounding boxes}
The function to compute the bounding box of a cell
is pretty straightforward.
@D Bounding box computation
@{function bbox(V::Verts, cell::Cell)
    d = size(V,2)
    @< Find cell vertices values @>
    @< Compute lower and upper points @>
    lower, upper
end
@}
@D Find cell vertices values
@{VS = Verts(0,d)
for i = 1:size(cell,1)
    VS = vcat(VS, reshape(V[cell[i], :], 1, 2))
end
@}
@D Compute lower and upper points
@{lower = mapslices(x->min(x...), VS, 1)
upper = mapslices(x->max(x...), VS, 1)
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Spatial index computation}
The aim of this function is to compute a \textit{spatial index} that maps
each cell to a set of cells which it may collide with.
This is achieved by profuse use of bounding boxes and interval trees. 
These last ones are implemented with the IntervalTrees library
(\url{https://github.com/BioJulia/IntervalTrees.jl})
@D Imports and aliases
@{using IntervalTrees
@}

@D Compute spatial index
@{function spatial_index(V::Verts, CV::Cells)
    d = size(V,2)
    cell_num = length(CV)
    @< Build the d-IntervalTrees @>
    @< Create the mapping @>
    mapping
end
@}
The basic idea is to "unfold" every $d$-dimensional bounding box into $d$ one-dimensional boxes.
To do so, one interval tree per dimension must be created. 
We build the $d$-trees by firstly building the intervals for each box and then the trees.
In this way we keep in memory the \texttt{boxes1D} array (which contains the intervals) for later use.
@D Build the d-IntervalTrees
@{IntervalsType = IntervalValue{Float64, Int64}
boxes1D = Array{IntervalsType, 2}(0, d)
for ci in 1:cell_num
    intervals = map((l,u)->IntervalsType(l,u,ci), bbox(V,CV[ci])...)
    boxes1D = vcat(boxes1D, intervals)
end
trees = mapslices(IntervalTree{Float64, IntervalsType}, sort(boxes1D, 1), 1)
@}
The \textit{spatial index} is returned as an array of \texttt{Int64} arrays.
The \texttt{intersect\_intervals} function returns every cell of which its bounding box collides with 
the $d$-intervals passed as argument. This function then is called for the $d$-intervals (stored in the \texttt{boxes1D} array) of every cell.
Obviously every cell collides with itself, so a set difference is performed for every cell to exclude itself from the mapping.
@D Create the mapping
@{function intersect_intervals(intervals)
    cells = Array{Int64,1}[]
    for axis in 1:d
        vs = map(i->i.value, intersect(trees[axis], intervals[axis]))
        push!(cells, vs)
    end
    mapreduce(x->x, intersect, cells)
end

mapping = Array{Int64,1}[]
for ci in 1:cell_num
    cell_indexes = setdiff(intersect_intervals(boxes1D[ci, :]), [ci])
    push!(mapping, cell_indexes)
end
@}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Segment intersection}
\label{seg_intersection}
Here is presented a basic segment intersection function.
It is based on the method presented here: \url{http://paulbourke.net/geometry/pointlineplane/}.
The function works only if $d=2$ and the cells are edges.
If there is an intersection, it returns a \texttt{Tuple\{Float64,Verts\}} where 
the \texttt{Float64} is the parameter of the intersection and the \texttt{Verts} 
is the approximate point of intersection. \\
\texttt{false} is returned in case of no intersection.
@D Segment intersection
@{function seg_intersection(V::Verts, cell1::Cell, cell2::Cell)
    x1,x2,y1,y2 = V[cell1, :]
    x3,x4,y3,y4 = V[cell2, :]

    denom = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1)
    a = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / denom
    b = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / denom

    if 0 <= a <= 1 && 0 <= b <= 1
        p = [(x1 + a*(x2-x1))  (y1 + a*(y2-y1))]
        return a, p
    end
    return false
end

@}

\section{Segment fragmentation}
This function computes the intersection of the \texttt{sigma} edge with the \texttt{sigma\_int} edges.
It modifies the \texttt{EV} matrix but returns the whole newly computed complex as a tuple of vertices and edges.
The \texttt{alphas} dictionary couples the parameter of every intersection
(the first value of the tuple returned by the \hyperref[seg_intersection]{\texttt{seg\_intersection}})
to the index of the vertex generated by the same intersection.
@D Segment fragmentation
@{function seg_fragmentation!(V::Verts, EV::Cells, sigma::Cell, sigma_int::Cells)
    alphas = Dict{Float64, Int64}()
    @< Compute intersections @>
    @< Rearrange edges @>
    V, EV
end
@}
We build the \texttt{alphas} dictionary and we add the new vertices to \texttt{V} in a straightforward way.
@D Compute intersections
@{for cell in sigma_int
    inters = seg_intersection(V, sigma, cell)
    if inters != false
        alpha, point = inters
        V = vcat(V, point)
        alphas[alpha] = size(V,1)
    end
end
@}
Rebuilding the \texttt{EV} matrix is more tricky. First of all we delete \texttt{sigma} from \texttt{EV} then 
we iterate over the sorted keys of \texttt{alphas} to append the new small edges to \texttt{EV}.
@D Rearrange edges
@{deleteat!(EV, findfirst(EV, sigma))
alphaskeys = sort(collect(keys(alphas)))
alphasnum = length(alphaskeys)
for a in 1:alphasnum
    if a == 1
        push!(EV, [sigma[1], alphas[alphaskeys[a]]])
    end
    if a == alphasnum
        push!(EV, [alphas[alphaskeys[a]], sigma[2]])
    else
        push!(EV, [alphas[alphaskeys[a]], alphas[alphaskeys[a+1]]])
    end
end
@}

%%%%%%%%%%%%%%%%%
\section{Testing}
@O test/jl/intersect.jl
@{using Base.Test
include("../../lib/jl/intersect.jl")

Xs = (
    [[[1 2];[3 2]],[[1,2]]],
    [[[1 3];[2 1]],[[1,2]]],
    [[[2 3];[3 1]],[[1,2]]],
    [[[1.5 1];[2.5 3]],[[1,2]]]
)

@< Skeletal union tests @>
@< Bounding box tests @>
@< Spatial index test @>
@< Segment intersection test @>
@< Segment fragmentation test @>
@}
@D Skeletal union tests
@{V,CV = skel_union(Xs)
@@testset "skel_union tests" begin
    @@test V == [[1 2];[3 2];[1 3];[2 1];[2 3];[3 1];[1.5 1];[2.5 3]]
    @@test CV == [[1,2],[3,4],[5,6],[7,8]]
end
@}
@D Bounding box tests
@{lower, upper = bbox(V, CV[2])
@@testset "bbox tests" begin
    @@test lower == [1 1]
    @@test upper == [2 3]
end
@}
@D Spatial index test
@{mapping = spatial_index(V,CV)
@@testset "spatial_index test" begin
    @@test mapping == [[2,4,3], [1,4,3], [2,1,4], [2,1,3]]
end
@}
@D Segment intersection test
@{intersection = seg_intersection(V,CV[1],CV[2])
@@testset "seg_intersection test" begin
    @@test intersection == (.25, [1.5 2.0])
end
@}
@D Segment fragmentation test
@{V,CV = seg_fragmentation!(V, CV, CV[1], CV[2:end])
@@testset "seg_fragmentation test" begin
    @@test V == [[1 2];[3 2];[1 3];[2 1];[2 3];[3 1];[1.5 1];[2.5 3];[1.5 2];[2.5 2];[2 2]]
    @@test CV == [[3,4],[5,6],[7,8],[1,9],[9,11],[11,10],[10,2]]
end
@}
\end{document}