\chapter{Introduction}

This thesis presents a Julia implementation
of a novel algorithm to combine two cellular complexes,
guaranteeing a minimal fragmentation of the resulting
complex \cite{Paoluzzi}. The algorithm has several applications, of which
the most common and obvious one are the Boolean operations
on solids. The whole system is based on LAR \cite{Dicarlo:2014:TNL:2543138.2543294}, 
a very general and versatile geometrical representation scheme.

\section{Boolean Operations}
Boolean operations are a set of operations between solids.
They took two solids and return one.
The common three operations are\footnote{On the top of them many other 
operations can be built using De Morgan's Laws. For example,
the exclusive disjunction (XOR) can be expressed as $(A \cup B) - (A \cap B)$}:


\begin{figure}[h]
    \begin{center}
        \includegraphics[width=.33\textwidth]{./img/bool-union.pdf}%
        \includegraphics[width=.33\textwidth]{./img/bool-intersection.pdf}%
        \includegraphics[width=.33\textwidth]{./img/bool-difference.pdf}%

        $A \cup B$\hspace{.28\textwidth}$A \cap B$\hspace{.28\textwidth}$A - B$
    \end{center}
\end{figure}

Boolean operations are very used through computer graphics, both 
in computer aided design and graphics for entertainment. 
For this reason, since the dawn of computer graphics,
several algorithms for Boolean operations 
have been developed and implemented. But most of them have
recurrent problems: the big ones are the excessive 
fragmentation of the cells in output and the huge conceptual
complexity of the implementations. This happens partially due to the inadequacy 
of mainstream geometric representations in
handling non-manifold solids, which are a common output of Boolean
operations; that's why our algorithm takes heavily advantage 
from the LAR scheme.

\section{LAR}
\label{sec:LAR}

LAR is a general representation scheme for geometric and topological
modeling. The domain of the scheme is provided by \textit{cellular complexes}
while its codomain is a set of \textit{sparse matrices}.
The main advantages of the scheme are:
\begin{enumerate}
    \item
    \textit{It is extremely effective to easily represent general non-manifold solids.}
    For example, the memory representation of a $d=3$ cellular complex using LAR 
    consists in only two binary sparse matrices for the topology and a bi-dimensional
    array for the geometry.
    \item
    \textit{Computation and analysis of cellular complexes is
    done only through easy linear algebra operations.} 
    The most common operation is the sparse matrix-vector 
    multiplication.
\end{enumerate}

In LAR we talk about cellular complexes which are made of cells, so we
call $d$-cell the $d$-dimensional cell: 0-cells are vertices,
1-cells are edges, 2-cells are faces, and so on.
Throughout this thesis, these names are completely
interchangeable.

An important concept is represented by the \textit{boundary} and 
\textit{coboundary operators}. They express the relation
between the cells of different dimension but of the same cellular complex.
Even these operators are stored in memory as sparse matrices 
and they can be applied using just a matrix multiplication.

The relation $\partial_d = \delta_{d-1}^\top$ (where $\partial_d$ 
is the $d$-boundary and $\delta_{d-1}$ is the $(d-1)$-coboundary)
is particularly handy. So, for example a 2-boundary expresses 
the relation from the edges to the faces of the same complex and
its transpose is the 1-coboundary that maps faces to edges.

An another concept of LAR used a lot in this thesis is the one of
\textit{skeleton}. A $(d-1)$-skeleton is the set of $(d-1)$-cells of
a $d$-complex. For example, a 2-skeleton of a 3-complex is the set
of all the faces of the complex.

\subsection{Historical notes}
\label{sec:history}
LAR has been developed for several years, in a joint collaboration 
between Roma Tre University and the University 
of Wisconsin at Madison \cite{ieee-tase}. The development of a Python 
prototype start in 2012 by A. Paoluzzi but was interrupted 
in December 2016 for various reasons. The development of the current
Julia implementation started few months later (March 2017) with
G. Martella and F. Furiani as main developers. This thesis is
the main core of the Julia implementation.


\section{Literate programming}
This thesis has been written using literate programming.
Literate programming is a programming paradigm in which the program
logic is explained in natural language and the code is embedded in macros.
Quoting Donald E. Knuth, the creator of the paradigm: 
\textit{``[Literate programming] allows a person to express programs in a stream of
consciousness order. [...] [Code can] be explored
in a psychologically correct order''} \cite{knuth}. 
With this premise it is easy to understand why literate programming 
is widely used for academic works.
When the goal is to learn and share knowledge, literate programming fits perfectly.


\section{Julia}

Julia is a relatively new high-level programming language targeted 
to numerical computing. The project was born back in 2009 and its first
stable version was released in 2012. As stated in the first blog post
on Julia's official website, the language has the goal
to be \textit{``Something that is dirt simple to learn, 
yet keeps the most serious hackers happy''}, with the speed of C, 
the dynamism of Ruby and the distributed power of Hadoop
\cite{julia}.

We choose Julia manly because of its elegance and
simplicity: using a lower level programming language
would have faded the underlying mathematical elegance
of the algorithm.




%%%%%%%%%%%%%%%%%%%%%%%
\chapter{The algorithm}
\label{ch:algorithm}
\section{Overview}
\label{sec:spatial_arrangement_overview}
The algorithm is based on the concept of recursive problem simplification 
(a sort of \textit{divide et impera} philosophy); if we have a $d$-complex, for every
($d-1$)-cell embedded into the $\mathbb{E}^d$ euclidean space, we bring the cell,
and every other cell that could intersect it, down into $\mathbb{E}^{d-1}$. We do this until
we reach the $d=1$ in $\mathbb{E}^1$ case; in here, we fragment all the $1$-cells.
Then, we travel back to the original $d$-dimension, and, for each
dimensional step, we build correct complexes from cells provided by the 
fragmentation of the lower dimension. 

\begin{figure}[h]
    \begin{center}
        \includegraphics[width=.25\textwidth]{./img/ch1-1.pdf}%
        \includegraphics[width=.25\textwidth]{./img/ch1-2.pdf}%
        \includegraphics[width=.25\textwidth]{./img/ch1-3.pdf}%
        \includegraphics[width=.25\textwidth]{./img/ch1-4.pdf}%

        (a)\hspace{.22\textwidth}(b)\hspace{.22\textwidth}(c)\hspace{.22\textwidth}(d)
    \end{center}
    
    \begin{center}
        \includegraphics[width=.25\textwidth]{./img/ch1-5.pdf}%
        \includegraphics[width=.25\textwidth]{./img/ch1-6.pdf}%
        \includegraphics[width=.25\textwidth]{./img/ch1-7.pdf}%
        \includegraphics[width=.25\textwidth]{./img/ch1-8.pdf}%

        (e)\hspace{.22\textwidth}(f)\hspace{.22\textwidth}(g)\hspace{.22\textwidth}(h)
    \end{center}
    \caption{Algorithm overview}
    \label{img:spatial}
\end{figure}

We have in input two cellular complexes [fig. \ref{img:spatial}, a], 
given as 2-skeletons, which are the sets of 2-cells 
[fig. \ref{img:spatial}, b, exploded]. Once we merged the skeletons
[ref. \ref{sec:skel_merge}], we individuate for each $2$-cell (that we will call $\sigma$)
all the other cells that could intersect it. We do this by computing
the spatial index: it is a mapping $\mathcal{I}(\sigma)$ from a cell $\sigma$ to every other 
cell $\tau$ of which $box(\sigma) \cap box(\tau) \neq \emptyset$, where 
the $box$ function provides the axis aligned bounding box (AABB) of a cell [fig. \ref{img:spatial}, c, 
$\sigma$ in red and $\mathcal{I}(\sigma)$ in blue]. The spatial arrangement
calculation is speeded up by storing the AABBs as dimensional wise intervals
into an interval tree \cite{interval_trees}. 
Now for each cell $\sigma$ we transform $\sigma \cup \mathcal{I}(\sigma)$ 
in a way that $\sigma$ lays on the $x_3=0$ plane [fig. \ref{img:spatial}, d] and we find the intersections 
of the $\mathcal{I}(\sigma)$ cells with $x_3=0$ plane. So we have a ``soup''
of 1-cells in $\mathbb{E}^2$ [fig. \ref{img:spatial}, e], and we fragment each 1-cell 
with every other cell obtaining a valid 1-skeleton [fig. \ref{img:spatial}, f].
From this data it is possible to build the 2-cells using the ALGORITHM 1
presented and explored by Paoluzzi et al. \cite{Paoluzzi}
[fig. \ref{img:spatial}, g, exploded]. The procedure to fragment 1-cells
on a plane and return a 2-complex is called \textit{planar arrangement} and it
is presented more in detail in the next section. When the planar arrangement is
complete, fragmented $\sigma$ can be transformed back to its original position
in $\mathbb{E}^3$. With every 2-cell correctly fragmented, we can use the 
already cited ALGORITHM 1 again to build a full 3-complex%
\footnote{This is possible because ALGORITHM 1 is (almost) dimension independent
[ref. \ref{ch:minimal_cycles}].} [fig. \ref{img:spatial}, h, exploded].


\section{The ``$1$-cells in $\mathbb{E}^2$'' base case}
\label{sec:planar_arrangement_overview}

\begin{figure}[h]
    \centering
    \includegraphics{./img/ch2-planararrangement.pdf}
    \caption{Planar arrangement overview}
    \label{img:planar}
\end{figure}

This is our base case. We have called \textit{planar arrangement} 
the procedure to handle this case since
it literally arranges a bunch of edges laying on a plane.
So, in input there are 1-cells in $\mathbb{E}^2$ and, optionally (but very
likely), the boundary of the original 2-cell $\sigma$ 
[fig. \ref{img:planar}, a, $\sigma$ in red].
We consider each edge and we fragment it with every other edge. This brings to
the creation of several coincident vertices: these will be eliminated
using a KD-Tree [fig. \ref{img:planar}, b, exploded]. 
At this point we have a perfectly fragmented 1-complex but many
edges are superfluous and must be eliminated; two kind of edges
are to discard: the ones outside the area of $\sigma$ and the ones
which are not part of a maximal biconnected component 
[ref. \ref{sec:biconnected_components}].
The result of this edge pruning outputs a
1-skeleton [fig. \ref{img:planar}, c, exploded].

After this, 2-cells must be computed:
for each connected component%
\footnote{It is legit to talk about a 1-skeleton as a graph: 
0-cells are nodes, 1-cells are edges and the boundary operator is
a incidence matrix.} we build a containment tree, which indicates
which component is spatially inside an other component.
Computing these relations, let us launch the ALGORITHM 1 \cite{Paoluzzi}
on each component and then combine the results to create 2-cells with non-intersecting 
shells\footnote{A 2-cell with a non-intersecting shell can be trivially defined
as a ``face with holes''; the correct definition is that it cannot 
be shrunk to the dimension of a point.} 
[fig. \ref{img:planar}, d, 2-cells numbered in green; please note that
cell 2 has cell 1 as an hole].

