\chapter{LAR}
\label{sec:LAR}

LAR is a general representation scheme for geometric and topological
modeling~\cite{Dicarlo:2014:TNL:2543138.2543294}. 
The domain of the scheme is provided by \textit{cellular complexes}
while its codomain is a set of \textit{sparse matrices}.
The main advantages of the scheme are:
\begin{enumerate}
    \item
    \textit{It is extremely effective to easily represent general non-manifold solids.}
    For example, the memory representation of a $d=3$ cellular complex using LAR 
    consists in only two binary sparse matrices for the topology and a bi-dimensional
    array for the geometry.
    \item
    \textit{Computation and analysis of cellular complexes is
    done only through easy linear algebra operations.} 
    The most common operation is the sparse matrix-vector 
    multiplication.
\end{enumerate}

In LAR we talk about cellular complexes which are made of cells, so we
call $d$-cell the $d$-dimensional cell: 0-cells are vertices,
1-cells are edges, 2-cells are faces, and so on.
Throughout this work, these names are completely
interchangeable.

An important concept is represented by the \textit{boundary} and 
\textit{coboundary operators}. They express the relation
between the cells of different dimension but of the same cellular complex.
Even these operators are stored in memory as sparse matrices 
and they can be applied using just a matrix multiplication.

The relation $\partial_d = \delta_{d-1}^\top$ (where $\partial_d$ 
is the $d$-boundary and $\delta_{d-1}$ is the $(d-1)$-coboundary)
is particularly handy. So, for example a 2-boundary expresses 
the incidence relation from faces to edges of a complex and
its transpose gives the 1-coboundary that maps edges to faces.

An another concept of LAR used a lot in this thesis is the one of
\textit{skeleton}. A $(d-1)$-skeleton is the set of $(d-1)$-cells of
a $d$-complex. For example, a 2-skeleton of a 3-complex is the set
of all the 2-faces of the complex.

\section{LAR fundamentals}
\label{sec:fundamentals}

\paragraph{LAR model}
A LAR model is a pair \emph{geometry, topology}. The \emph{geometry} is specified by the  position vectors of \emph{vertices} in a Euclidean space $\E^d$ of points with $d$ coordinates. The \emph{topology} is specified by one or more bases of singleton $k$-chains (i.e.~$k$-cells) for $0 \leq k\leq d$. The vertex sharing between cells implicitly provides the attachment maps between cells of various dimensions.
Vertex positions are represented, by columns, by a 2-array of $d$ real coordinates.

\paragraph{Chains as arrays}
Chain-based modeling and computing~\cite{DBLP:journals/corr/abs-0812-3249} is based on representation of $p$-cell subsets as \emph{chains}, elements of \emph{linear} spaces $C_p$ ($0\leq p\leq d$) generated by the space decomposition induced by a \emph{cellular complex}, also said \emph{CW- complex}.
Chains can be simply represented as arrays of signed integers, one of simplest and more efficient data structure of most languages, particularly when oriented to scientific computing.
Therefore, basic algebraic operations on chains as vectors (sum and product times a scalar) are implemented over arrays.

\paragraph{Characteristic matrices}
The LAR \emph{representation scheme}~\cite{Requicha:1980:RRS:356827.356833}, i.e.~our mapping between mathematical models of solids and their computer representations, uses linear \emph{chain spaces} $C_p$ as models, and sparse \emph{characteristic matrices} $M_p$  of $p$-cells as symbolic representations, where the $p$-cell $\sigma^k\in\Lambda_p$ is represented as the $k$-th binary row of the  sparse characteristic matrix $M_p: C_0\to C_p$.

\paragraph{Boundary and coboundary matrices}

The boundary matrix $[\partial_p]$ is the matrix of the boundary operator $\partial_p: C_p\to C_{p-1}$ ($1\leq p\leq d$) that for each \emph{chain} $c_p\in C_p$ returns the  boundary $(p-1)$-cycle of its $(d-1)$-faces.  A boundary operator is linear: $\partial_p c + d = \partial_p c + \partial_p d$, for each $c,d\in C_p$. A cycle is a chain without boundary. Hence, t\emph{he} boundary of a boundary is the zero map: $partial_{p-1} \circ partial_p = 0$ ($2\leq p\leq d$).

\paragraph{Incidence matrices}
Incidence operators between chain spaces of different dimension are easy to compute by matrix products of characteristic matrices (see Section~\ref{matrices}), possibly transposed.
Since both characteristic and operator matrices are very sparse, their products are computed with  specialized algorithms for very sparse matrices, whose complexity is roughly linear in the size of the output sparse matrix, i.e., in the number of its stored non-zero elements.
Incidence queries and other types of geometric or topological computations are not performed element-wise, that necessarily require iterative or recursive programming patterns, but only require matrix product times whole chains (sets of cells), so adapting naturally to parallel and/or dataflow computational patterns found in HPC and CNN architectures.

\paragraph{Validity test of a representation}
Data validity is easy to test by checking for satisfaction of basic equations $\partial\partial=\emptyset$ of a chain complex.


\paragraph{Space arrangments}

Given a finite collection $\mathcal{S}$ of cellular complexes in $\E^d$,
$d \in \{2,3\}$, the \emph{arrangement} $\mathcal{A}(\mathcal{S})$ is the
decomposition of $\E^d$ into connected cells of dimensions
$0, 1, \ldots, d$ induced by $\mathcal{S}$.
In this repo, we provide an efficient computation of the arrangement produced by a given set of cellular complexes in either 2D or 3D. Our goal is to provide a
complete description of the plane or space decomposition induced by the
input, into cells of dimensions 0, 1, 2 or 3.
The module \texttt{LARLIB.jl} is based on the algorithms introduced in~\cite{DBLP:journals/corr/PaoluzziSD17} to compute the $d$-space arrangement generated by a collection of $(d$-$1)$-complexes. A general description of both the motivations and the features of this Julia module is given in~\cite{DBLP:journals/corr/abs-1710-07819}.

With abuse of language, we consider a finite cellular complex $X$ as generated by a discrete partition of an Euclidean space. In computing a cellular complex as the space \emph{arrangement} of a collection of geometric objects $\mathcal{S}$, i.e.~when  $X := \mathcal{A}(\mathcal{S})$, we actually compute the whole \emph{chain complex} $C_\bullet$ generated by $X$, i.e.:
\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=0.30\linewidth]{img/chains} 
   \label{fig:chains}
\end{figure}
\vspace{-4mm}
\noindent
where $C_p$ ($0\geq p\geq 3$) is a linear space of \emph{$p$-chains} (subsets  of $p$-cells with algebraic structure).  The linear operators $\partial_p$ and $\delta_p$ are called \emph{boundary} and \emph{coboundary}, respectively, with 
\[
\partial_{p-1}\circ\partial_p  = \emptyset = \delta_{p}\circ\delta_{p-1} ,
\]
and where 
\[
\delta_{p-1} = \partial_p^\top, \qquad 1\leq p\leq 3.
\] 



\section{Data structures and transformations}
\label{sec:datastructures}



In this section we introduce the basic data objects of the \texttt{LARLIB} module,
i.e., incidence relations, chain bases, and chain transformations. The ground concept of a \emph{chain complex} is a cellular decomposition of a $d$-space into sets of connected $p$-cells ($0\leq p\leq\ d$). 



\subsection{Examples}
\label{sec:examples}

\begin{example}[3D cubical mesh]
\label{ex:boundary1}


A very simple example of 3D cubical mesh is given here. When considered as a solid model,  a \emph{boundary representation} would be normally applied to it. If used as the domain of a simulation, a \emph{decompositive representation} would be usually chosen. Both can be derived by the LAR scheme, given below. A picture of the mesh with numbered $p$-cells in different colors ($0\leq p\leq 3$) is shown in Figure~\ref{fig:intro-1}.

%-------------------------------------------------------------------------------
@d LAR decompositive representation 
@{using LARVIEW

# Simple mesh of two 3-cuboids
V,cells = LARLIB.larCuboids([2,1,1],true)
VV,EV,FV,CV = cells
larmodel = V,(VV,EV,FV,CV)
LARVIEW.viewnumbered(larmodel)
@}
%-------------------------------------------------------------------------------

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=\textwidth]{img/intro-1.pdf} 
   \caption{A cubical 3-mesh with two 3-cells. Notice that $p$-cells of index 1 are also indexed by 0 in the picture, due to (current) incompatibilities by the \texttt{pyplasm} library, used for mesh drawing, and Julia.}
   \label{fig:intro-1}
\end{figure}

The geometric embedding of the grid, given the array $V$ of vertices, and the indexing of $p$-cells as subsets of vertices are given below.

{\small\begin{verbatim}
julia> V
3�12 Array{Int64,2}:
 0  0  0  0  1  1  1  1  2  2  2  2
 0  0  1  1  0  0  1  1  0  0  1  1
 0  1  0  1  0  1  0  1  0  1  0  1
julia> print(VV)
Array{Int64,1}[[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12]]
julia> print(EV)
Array{Int64,1}[[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[1,3],[2,4],[5,7],
[6,8],[9,11],[10,12],[1,5],[2,6],[3,7],[4,8],[5,9],[6,10],[7,11],[8,12]]
julia> print(FV)
Array{Int64,1}[[1,2,3,4],[5,6,7,8],[9,10,11,12],[1,2,5,6],[3,4,7,8],
[5,6,9,10],[7,8,11,12],[1,3,5,7],[2,4,6,8],[5,7,9,11],[6,8,10,12]]
julia> print(CV)
Array{Int64,1}[[1,2,3,4,5,6,7,8],[5,6,7,8,9,10,11,12]]
\end{verbatim}
}
\end{example}

\begin{example}[Input/output of space arrangement algorithm]
\end{example}



\subsection{Data structures}

\label{sec:data} All data structures are either arrays, or sparse arrays, or arrays of arrays. We introduce here some stardard notations, largely used in the following. In particular, we use the symbols \texttt{V}, \texttt{E}, \texttt{F}, \texttt{C}, to denote the arrays of \emph{vertices}, \emph{edges}, \emph{faces}, and \emph{cells},  i.e., to denote the 0-, 1-, 2-, and 3-cells, respectively. 

With some abuse of language, each \emph{$p$-cell} or \emph{elementary $p$-chain} is represented as the \texttt{Array\{Int64,1\}} of the integer indices of its $(p-1)$-faces, either signed or non-signed depending on the consideration of the orientations of the cells.


\paragraph{Incidence relations}

By definition of cellular complex, a $q$-cell $\tau$ and a $r$-cell $\sigma$, with $q\leq r$, either do not intersect or share a common \emph{$p$-face} ($0\leq p\leq q,r$).

Hence in 3D we may consider up to $16=4\times 4$ binary incidence relations between $V,E,F,C$, denoted respectively \texttt{VV}, \texttt{VE}, \texttt{VF}, \texttt{VC}, and
\texttt{EV}, \texttt{EE}, \texttt{EF}, \texttt{EC}, etc, etc.  Such incidence relations are represented in Julia as \texttt{Array\{Array\{Int64,1\},1\}} of integer indices. With reference to the cellular complex in Figure~\ref{fig:intro-1}:

{\small\begin{verbatim}
EV = [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[1,3],[2,4],[5,7],[6,8],
      [9,11],[10,12],[1,5],[2,6],[3,7],[4,8],[5,9],[6,10],[7,11],[8,12]]
\end{verbatim}}
\noindent where \texttt{EV[4] = [7,8]} simply means the 1-cell (edge) indexed by 4 is incident to vertices indexed by 7 and 8. Analogous readings hold for all other binary relationships.


\paragraph{Chain bases}

A chain complex is a sequence of linear boundary transformations between a sequence of linear spaces of chains. The set of $p$-cells, considered as the set of singleton $p$-chains, provides the basis for generating the whole set of $p$-chains via linear combinations with the elements of an additive group, normally either $(+,\Z_2=\{0,1\})$ or $(+,\Z_3\simeq\{-1,0,1\})$.

LAR describes the bases of $p$-chains $(0\leq p\leq 3)$ using sparse characteristic matrices  $M_0, M_1, M_2, M_3$ derived from the relations \texttt{VV}, \texttt{EV}, \texttt{FV}, \texttt{CV}, respectively  (see~\cite{Dicarlo:2014:TNL:2543138.2543294}).
Their compressed-sparse-column matrices are generated as follows:
{\small\begin{verbatim}
cscEV = characteristicMatrix(EV)
cscFV = characteristicMatrix(FV)
cscCV = characteristicMatrix(CV)
\end{verbatim}}

The characteristic matrix \texttt{cscFV} for the incidence \texttt{FV} of the complex in Figure~\ref{fig:intro-1} is given in Figure~\ref{fig:intro-0}

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
\begin{center}
\begin{minipage}[c]{0.5\textwidth}
\small\begin{verbatim}
julia> full(LARLIB.characteristicMatrix(FV))
11x12 Array{Int8,2}:
 1  1  1  1  0  0  0  0  0  0  0  0
 0  0  0  0  1  1  1  1  0  0  0  0
 0  0  0  0  0  0  0  0  1  1  1  1
 1  1  0  0  1  1  0  0  0  0  0  0
 0  0  1  1  0  0  1  1  0  0  0  0
 0  0  0  0  1  1  0  0  1  1  0  0
 0  0  0  0  0  0  1  1  0  0  1  1
 1  0  1  0  1  0  1  0  0  0  0  0
 0  1  0  1  0  1  0  1  0  0  0  0
 0  0  0  0  1  0  1  0  1  0  1  0
 0  0  0  0  0  1  0  1  0  1  0  1
\end{verbatim}
\end{minipage}
\end{center}
   \caption{Dense characteristic matrix \texttt{cscFV} for the incidence \texttt{FV} of the small complex in Figure~\ref{fig:intro-1}}
   \label{fig:intro-0}
\end{figure}

\subsection{Chain transformations}

\subsubsection{(Co)boundary transformations}


\begin{example}[Unsigned matrix of $\partial_2$]

In this case we get the Compressed Sparse Column matrix representation $[\partial_2]$ of the unsigned operator, i.e. with values in $\Z_2=\{0,1\}$, shown \emph{dense} in Figure~\ref{fig:intro-3}, by computing
\[
\partial_2 = \small\texttt{LARLIB.uboundary2(FV,EV)}.
\]
The generated sparse matrix is shown dense in Figure~\ref{fig:intro-3}.
Just notice that in Example~\ref{ex:boundary1} there are eleven 2-cells and twenty 1-cells, and that such ordered bases of 2-chains and 1-chains, respectively, are orderly associated to the rows and to the columns of $[\partial_2]$

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
\small\begin{verbatim}
julia> full(LARLIB.uboundary2(FV,EV))
11×20 Array{Int8,2}:
 1  1  0  0  0  0  1  1  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  1  1  0  0  0  0  1  1  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  1  1  0  0  0  0  1  1  0  0  0  0  0  0  0  0
 1  0  1  0  0  0  0  0  0  0  0  0  1  1  0  0  0  0  0  0
 0  1  0  1  0  0  0  0  0  0  0  0  0  0  1  1  0  0  0  0
 0  0  1  0  1  0  0  0  0  0  0  0  0  0  0  0  1  1  0  0
 0  0  0  1  0  1  0  0  0  0  0  0  0  0  0  0  0  0  1  1
 0  0  0  0  0  0  1  0  1  0  0  0  1  0  1  0  0  0  0  0
 0  0  0  0  0  0  0  1  0  1  0  0  0  1  0  1  0  0  0  0
 0  0  0  0  0  0  0  0  1  0  1  0  0  0  0  0  1  0  1  0
 0  0  0  0  0  0  0  0  0  1  0  1  0  0  0  0  0  1  0  1
\end{verbatim}
   \caption{Dense \emph{unsigned} $[\partial_2]$ matrix for the small complex in Figure~\ref{fig:intro-1}}
   \label{fig:intro-3}
\end{figure}

\end{example}


\begin{example}[Signed matrix of $\partial_2$]

The computation of the matrix of the signed boundary operator, i.e. with values in $\Z_3\simeq\{-1,0,1\}$, is shown \emph{dense} in Figure~\ref{fig:intro-3}.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
\small\begin{verbatim}
julia> full(LARLIB.boundary2(FV,EV))
11×20 Array{Int8,2}:
 -1   1   0  0   0   0  1  -1   0   0   0   0   0   0  0   0   0   0   0  0
  0   0  -1  1   0   0  0   0   1  -1   0   0   0   0  0   0   0   0   0  0
  0   0   0  0  -1   1  0   0   0   0   1  -1   0   0  0   0   0   0   0  0
 -1   0   1  0   0   0  0   0   0   0   0   0   1  -1  0   0   0   0   0  0
  0  -1   0  1   0   0  0   0   0   0   0   0   0   0  1  -1   0   0   0  0
  0   0   1  0  -1   0  0   0   0   0   0   0   0   0  0   0  -1   1   0  0
  0   0   0  1   0  -1  0   0   0   0   0   0   0   0  0   0   0   0  -1  1
  0   0   0  0   0   0  1   0  -1   0   0   0  -1   0  1   0   0   0   0  0
  0   0   0  0   0   0  0  -1   0   1   0   0   0   1  0  -1   0   0   0  0
  0   0   0  0   0   0  0   0   1   0  -1   0   0   0  0   0  -1   0   1  0
  0   0   0  0   0   0  0   0   0   1   0  -1   0   0  0   0   0  -1   0  1
\end{verbatim}
   \caption{Dense \emph{signed} $[\partial_2]$ matrix for the small complex in Figure~\ref{fig:intro-1}}
   \label{fig:intro-3}
\end{figure}

\end{example}


\subsubsection{Affine transformations}


\paragraph{Geometric embedding}

The \texttt{V} array, of Julia type \texttt{Array\{Float64,2\}}, contains by columns the coordinates of position vectors of $d$-points associated to \emph{vertices} (0-cells) of the cellular complex $X \subseteq \R^d$. Hence \texttt{V} specifies the geometric embedding of $X$.


\subsection{Data transformations}
\label{sec:transformations}



\section{Historical notes}
\label{sec:history}
LAR has been developed for several years, in a joint collaboration 
between Roma Tre University and the University 
of Wisconsin at Madison \cite{ieee-tase}. The development of a Python 
prototype start in 2012 by A. Paoluzzi but was interrupted 
in December 2016 for various reasons. The development of the current
Julia implementation started few months later (March 2017) with
G. Martella and F. Furiani as main developers. This thesis is
the main core of the Julia implementation.


\section{Literate programming}
This package has been developed using literate programming.
Literate programming is a programming paradigm in which the program
logic is explained in natural language and the code is embedded in macros.
Quoting Donald E. Knuth, the creator of the paradigm: 
\textit{``[Literate programming] allows a person to express programs in a stream of
consciousness order. [...] [Code can] be explored
in a psychologically correct order''} \cite{knuth}. 
With this premise it is easy to understand why literate programming 
is widely used for academic works.
When the goal is to learn and share knowledge, literate programming fits perfectly.


\section{Julia}

Ths implementation has been made in Julia
Julia is a relatively new high-level programming language targeted 
to numerical computing. The project was born back in 2009 and its first
stable version was released in 2012. As stated in the first blog post
on Julia's official website, the language has the goal
to be \textit{``Something that is dirt simple to learn, 
yet keeps the most serious hackers happy''}, with the speed of C, 
the dynamism of Ruby and the distributed power of Hadoop
\cite{julia}.


%%%%%%%%%%%%%%%%%%%%%%%
\chapter{The arrangement algorithm}
\label{ch:arrangement_algorithm}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{./img/cube10x10.pdf}
    \caption{Arrangement of 2000($=2\times10\times10\times10$) cubes}
\end{figure}





\section{Overview}
\label{sec:spatial_arrangement_overview}
The algorithm is based on the concept of recursive problem simplification 
(a sort of \textit{divide et impera} philosophy); if we have a $d$-complex, for every
($d-1$)-cell embedded into the $\mathbb{E}^d$ euclidean space, we bring the cell,
and every other cell that could intersect it, down into $\mathbb{E}^{d-1}$. We do this until
we reach the $d=1$ in $\mathbb{E}^1$ case; in here, we fragment all the $1$-cells.
Then, we travel back to the original $d$-dimension, and, for each
dimensional step, we build correct complexes from cells provided by the 
fragmentation of the lower dimension. 

\begin{figure}[h]
    \begin{center}
        \includegraphics[width=.25\textwidth]{./img/ch1-1.pdf}%
        \includegraphics[width=.25\textwidth]{./img/ch1-2.pdf}%
        \includegraphics[width=.25\textwidth]{./img/ch1-3.pdf}%
        \includegraphics[width=.25\textwidth]{./img/ch1-4.pdf}%

        (a)\hspace{.22\textwidth}(b)\hspace{.22\textwidth}(c)\hspace{.22\textwidth}(d)
    \end{center}
    
    \begin{center}
        \includegraphics[width=.25\textwidth]{./img/ch1-5.pdf}%
        \includegraphics[width=.25\textwidth]{./img/ch1-6.pdf}%
        \includegraphics[width=.25\textwidth]{./img/ch1-7.pdf}%
        \includegraphics[width=.25\textwidth]{./img/ch1-8.pdf}%

        (e)\hspace{.22\textwidth}(f)\hspace{.22\textwidth}(g)\hspace{.22\textwidth}(h)
    \end{center}
    \caption{Algorithm overview}
    \label{img:spatial}
\end{figure}

We have in input two cellular complexes [fig. \ref{img:spatial}, a], 
given as 2-skeletons, which are the sets of 2-cells 
[fig. \ref{img:spatial}, b, exploded]. Once we merged the skeletons
[ref. \ref{sec:skel_merge}], we individuate for each $2$-cell (that we will call $\sigma$)
all the other cells that could intersect it. We do this by computing
the spatial index: it is a mapping $\mathcal{I}(\sigma)$ from a cell $\sigma$ to every other 
cell $\tau$ of which $box(\sigma) \cap box(\tau) \neq \emptyset$, where 
the $box$ function provides the axis aligned bounding box (AABB) of a cell [fig. \ref{img:spatial}, c, 
$\sigma$ in red and $\mathcal{I}(\sigma)$ in blue]. The spatial arrangement
calculation is speeded up by storing the AABBs as dimensional wise intervals
into an interval tree \cite{interval_trees}. 
Now for each cell $\sigma$ we transform $\sigma \cup \mathcal{I}(\sigma)$ 
in a way that $\sigma$ lays on the $x_3=0$ plane [fig. \ref{img:spatial}, d] and we find the intersections 
of the $\mathcal{I}(\sigma)$ cells with $x_3=0$ plane. So we have a ``soup''
of 1-cells in $\mathbb{E}^2$ [fig. \ref{img:spatial}, e], and we fragment each 1-cell 
with every other cell obtaining a valid 1-skeleton [fig. \ref{img:spatial}, f].
From this data it is possible to build the 2-cells using the ALGORITHM 1
presented and explored by Paoluzzi et al. \cite{Paoluzzi}
[fig. \ref{img:spatial}, g, exploded]. The procedure to fragment 1-cells
on a plane and return a 2-complex is called \textit{planar arrangement} and it
is presented more in detail in the next section. When the planar arrangement is
complete, fragmented $\sigma$ can be transformed back to its original position
in $\mathbb{E}^3$. With every 2-cell correctly fragmented, we can use the 
already cited ALGORITHM 1 again to build a full 3-complex%
\footnote{This is possible because ALGORITHM 1 is (almost) dimension independent
[ref. \ref{ch:minimal_cycles}].} [fig. \ref{img:spatial}, h, exploded].


\section{The ``$1$-cells in $\mathbb{E}^2$'' base case}
\label{sec:planar_arrangement_overview}

\begin{figure}[h]
    \centering
    \includegraphics{./img/ch2-planararrangement.pdf}
    \caption{Planar arrangement overview}
    \label{img:planar}
\end{figure}

This is our base case. We have called \textit{planar arrangement} 
the procedure to handle this case since
it literally arranges a bunch of edges laying on a plane.
So, in input there are 1-cells in $\mathbb{E}^2$ and, optionally (but very
likely), the boundary of the original 2-cell $\sigma$ 
[fig. \ref{img:planar}, a, $\sigma$ in red].
We consider each edge and we fragment it with every other edge. This brings to
the creation of several coincident vertices: these will be eliminated
using a KD-Tree [fig. \ref{img:planar}, b, exploded]. 
At this point we have a perfectly fragmented 1-complex but many
edges are superfluous and must be eliminated; two kind of edges
are to discard: the ones outside the area of $\sigma$ and the ones
which are not part of a maximal biconnected component 
[ref. \ref{sec:biconnected_components}].
The result of this edge pruning outputs a
1-skeleton [fig. \ref{img:planar}, c, exploded].

After this, 2-cells must be computed:
for each connected component%
\footnote{It is legit to talk about a 1-skeleton as a graph: 
0-cells are nodes, 1-cells are edges and the boundary operator is
a incidence matrix.} we build a containment tree, which indicates
which component is spatially inside an other component.
Computing these relations, let us launch the ALGORITHM 1 \cite{Paoluzzi}
on each component and then combine the results to create 2-cells with non-intersecting 
shells\footnote{A 2-cell with a non-intersecting shell can be trivially defined
as a ``face with holes''; the correct definition is that it cannot 
be shrunk to the dimension of a point.} 
[fig. \ref{img:planar}, d, 2-cells numbered in green; please note that
cell 2 has cell 1 as an hole].


\section{Implementation}

Our implementation of this algorithm does not go over
$d=3$. It has been split in
multiple chapters in this book:

\begin{itemize}[noitemsep]
    \item Spatial Arrangement [ch. \ref{ch:spatial_arrangement}]: 
        It is the implementation of the ``$1$-cells in $\mathbb{E}^2$'' base case.
    \item Planar Arrangement [ch. \ref{ch:planar_arrangement}]:
        This treats the $d=3$ case. 
    \item Dimension travel [ch. \ref{ch:dimension_travel}]:
        Here are contained the utilities to travel from a
        dimension to another.
    \item Minimal cycles computation [ch. \ref{ch:minimal_cycles}]:
        This is dedicated to the implementation of the ALGORITHM 1
        described by Paoluzzi et Al. \cite{Paoluzzi}.
\end{itemize}